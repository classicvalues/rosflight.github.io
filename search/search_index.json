{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to ROSflight ROSflight is an autopilot system designed from the ground up with researchers in mind, and for easy integration with ROS . Its purpose is to accomplish two main tasks: Stream high-rate sensor data from the embedded flight controller to ROS Provide a simple API for sending control setpoints to the embedded flight controller A ROSflight setup consists of two main components: The embedded flight controller: Typically an OpenPilot Revo or one of its variants, running the ROSflight firmware The companion computer: Any computer that runs ROS, is located on the vehicle, and has a physical serial connection to the embedded flight controller Why ROSflight? There are a lot of excellent autopilots out there with a lot of great firmware options. Why did we feel like the world needed ROSflight? Because in our experience none of the other available options satisfied our research needs. Specifically, we needed an autopilot that could stream sensor data at high rates, easily accept control setpoints from a companion computer, and accomplish all of this with a lean, easy-to-understand code base. The other options that we tried were limited in bandwidth for streaming sensor data, and the APIs for sending control setpoints were confusing and difficult to implement. Perhaps most importantly, the code was sometimes so complex (feature-rich, but complicated) that it was difficult to figure out what the autopilot was actually doing. In talking to other researchers and industry members, we found that many people shared similar frustrations. So we decided to create and share the autopilot we wanted, hoping it will be useful to other people as well. Our Vision Perhaps more important than what we are trying to accomplish with ROSflight is what we are not trying to accomplish. This is not intended to be, out-of-the-box, a fully-featured autopilot for high-level tasks such as autonomous GPS waypoint following. There are many good autopilots out there that already do this. Instead, ROSflight is intended to provide the minimal functionality required to keep a multirotor or fixed-wing vehicle in the air, and to serve as a building block for writing new code to perform these higher-level tasks. (The ROSplane and ROScopter projects are excellent examples of what can be accomplished by building on top of the ROSflight architecture.) Therefore, one of the primary objectives of the ROSflight autopilot is to avoid feature creep and remain lean . We hope that others will extend our code and build on top of it, and would love to hear about your successes. But for the most part, we will not be incorporating these new features back into the main project. Instead, we hope that ROSflight will remain a lean, core code base that will continue to serve as a launch pad for exciting new projects and applications.","title":"Home"},{"location":"#welcome-to-rosflight","text":"ROSflight is an autopilot system designed from the ground up with researchers in mind, and for easy integration with ROS . Its purpose is to accomplish two main tasks: Stream high-rate sensor data from the embedded flight controller to ROS Provide a simple API for sending control setpoints to the embedded flight controller A ROSflight setup consists of two main components: The embedded flight controller: Typically an OpenPilot Revo or one of its variants, running the ROSflight firmware The companion computer: Any computer that runs ROS, is located on the vehicle, and has a physical serial connection to the embedded flight controller","title":"Welcome to ROSflight"},{"location":"#why-rosflight","text":"There are a lot of excellent autopilots out there with a lot of great firmware options. Why did we feel like the world needed ROSflight? Because in our experience none of the other available options satisfied our research needs. Specifically, we needed an autopilot that could stream sensor data at high rates, easily accept control setpoints from a companion computer, and accomplish all of this with a lean, easy-to-understand code base. The other options that we tried were limited in bandwidth for streaming sensor data, and the APIs for sending control setpoints were confusing and difficult to implement. Perhaps most importantly, the code was sometimes so complex (feature-rich, but complicated) that it was difficult to figure out what the autopilot was actually doing. In talking to other researchers and industry members, we found that many people shared similar frustrations. So we decided to create and share the autopilot we wanted, hoping it will be useful to other people as well.","title":"Why ROSflight?"},{"location":"#our-vision","text":"Perhaps more important than what we are trying to accomplish with ROSflight is what we are not trying to accomplish. This is not intended to be, out-of-the-box, a fully-featured autopilot for high-level tasks such as autonomous GPS waypoint following. There are many good autopilots out there that already do this. Instead, ROSflight is intended to provide the minimal functionality required to keep a multirotor or fixed-wing vehicle in the air, and to serve as a building block for writing new code to perform these higher-level tasks. (The ROSplane and ROScopter projects are excellent examples of what can be accomplished by building on top of the ROSflight architecture.) Therefore, one of the primary objectives of the ROSflight autopilot is to avoid feature creep and remain lean . We hope that others will extend our code and build on top of it, and would love to hear about your successes. But for the most part, we will not be incorporating these new features back into the main project. Instead, we hope that ROSflight will remain a lean, core code base that will continue to serve as a launch pad for exciting new projects and applications.","title":"Our Vision"},{"location":"algorithms/estimator/","text":"Estimator Introduction The estimator is used to calculate an estimate of the attitude and angular velocity of the multirotor. It is assumed that the flight controller is mounted rigidly to the body of the aircraft (perhaps with dampening material to remove vibrations from the motors), such that measurements of the on-board IMU are consistent with the motion of the aircraft. Due to the limited computational power on the embedded processor, and to calculate attitude estimates at speeds up to 8000Hz, a simple complementary filter is used, rather than an extended Kalman filter. In practice, this method works extremely well, and it used widely throughout commercially available autopilots. There are a variety of complementary filters, but the general theory is the same. A complementary filter is a method that combines low and high frequency data (complementary in frequency bandwidth). It can be used to fuse the measurements from a gyroscope, accelerometer and sometimes magnetometer to produce an estimate of the attitude of the MAV. Complementary Filtering The idea behind complementary filtering is to try to get the \"best of both worlds\" of gyros and accelerometers. Gyros are very accurate in short spaces of time, but they are subject to low-frequency drift. Accelerometers don't drift in the long scheme of things, but they experience high-frequency noise as the MAV moves about. So, to solve these problems, the complementary filter primarily propagates states using gyroscope measurements, but then corrects drift with the accelerometer, which is a partial source of attitude measurements. In a general sense, it is like taking a high-pass filtered version of gyroscope measurements, and a low-pass filtered version of accelerometers, and fusing the two together in a manner that results in an estimate that is stable over time, but also able to handle quick transient motions. For an excellent review of the theory of complementary filtering, consult Mahony's Nonlinear Complementary Filtering on SO(3) paper 1 . Attitude Representation There are a number of ways to represent the attitude of a MAV. Often, attitude is represented in terms of the Euler angles yaw, pitch and roll, but it can also be represented in other ways, such as rotation matrices, and quaternions. Euler Angles Euler angles represent rotations about three different axes, usually, the z, y, and x axes in that order. This method is often the most easy for users to understand and interpret, but it is by far the least computationally efficient. To propagate euler angles, the following kinematics are employed: \\begin{equation} \\begin{bmatrix} \\dot{\\phi} \\\\ \\dot{\\theta} \\\\ \\dot{\\psi} \\\\ \\end{bmatrix} = \\begin{bmatrix} 1 \\sin(\\phi) \\tan(\\theta) \\cos(\\phi)\\tan(\\theta) \\\\ 0 \\cos(\\phi) -\\sin(\\phi) \\\\ 0 \\frac{\\sin(\\phi)}{\\cos(\\theta)} \\frac{\\cos(\\phi)}{\\cos(\\theta)} \\\\ \\end{bmatrix} \\begin{bmatrix} p \\\\ q \\\\ r \\\\ \\end{bmatrix} \\end{equation} \\begin{equation} \\begin{bmatrix} \\dot{\\phi} \\\\ \\dot{\\theta} \\\\ \\dot{\\psi} \\\\ \\end{bmatrix} = \\begin{bmatrix} 1 & \\sin(\\phi) \\tan(\\theta) & \\cos(\\phi)\\tan(\\theta) \\\\ 0 & \\cos(\\phi) & -\\sin(\\phi) \\\\ 0 & \\frac{\\sin(\\phi)}{\\cos(\\theta)} & \\frac{\\cos(\\phi)}{\\cos(\\theta)} \\\\ \\end{bmatrix} \\begin{bmatrix} p \\\\ q \\\\ r \\\\ \\end{bmatrix} \\end{equation} Note the large number of trigonometric functions associated with this propagation. In a complementary filter, this will be evaluated at every measurement, and the non-linear coupling between \\omega \\omega and the attitude becomes very expensive, particularly on embedded processors. Another shortcoming of euler angles is known as \"gimbal lock\". Gimbal lock occurs at the \"singularity\" of the euler angle representation, or pitched directly up or down. The problem occurs because there is more than one way to represent this particular rotation. There are some steps one can take to handle these issues, but it is a fundamental problem associated with using euler angles, and motivates the other attitude representations. Rotation Matrix Rotation matrices, are often used in attitude estimation, because they do not suffer from gimbal lock, are quickly converted to and from euler angles, and because of their simple kinematics. \\begin{equation} \\dot{R} = \\lfloor\\omega\\rfloor R \\end{equation} \\begin{equation} \\dot{R} = \\lfloor\\omega\\rfloor R \\end{equation} where \\lfloor\\omega\\rfloor \\lfloor\\omega\\rfloor is the skew-symmetric matrix of \\omega \\omega , and is related to calculating the cross product. \\begin{equation} \\lfloor\\omega\\rfloor = \\begin{bmatrix} 0 -r q \\\\ r 0 -p \\\\ -q p 0 \\end{bmatrix} \\end{equation} \\begin{equation} \\lfloor\\omega\\rfloor = \\begin{bmatrix} 0 & -r & q \\\\ r & 0 & -p \\\\ -q & p & 0 \\end{bmatrix} \\end{equation} This propagation step is linear with respect to the angular rates, which simplifies calculation significantly. A rotation matrix from the inertial frame to body frame can be constructed from euler angles via the following formula: \\newcommand{\\ct}{c\\theta} \\newcommand{\\cp}{c\\phi} \\newcommand{\\cs}{c\\psi} \\newcommand{\\st}{s\\theta} \\newcommand{\\sphi}{s\\phi} \\newcommand{\\spsi}{s\\psi} \\begin{equation} R = \\begin{bmatrix} \\ct\\cs \\ct\\spsi -\\st \\\\ \\sphi\\st\\cs-\\cp\\spsi \\sphi\\st\\spsi+\\cp\\cs \\sphi\\ct \\\\ \\cp\\st\\cs+\\sphi\\spsi \\cp\\st\\spsi-\\sphi\\cs \\sphi\\st \\\\ \\end{bmatrix} \\end{equation} \\newcommand{\\ct}{c\\theta} \\newcommand{\\cp}{c\\phi} \\newcommand{\\cs}{c\\psi} \\newcommand{\\st}{s\\theta} \\newcommand{\\sphi}{s\\phi} \\newcommand{\\spsi}{s\\psi} \\begin{equation} R = \\begin{bmatrix} \\ct\\cs & \\ct\\spsi & -\\st \\\\ \\sphi\\st\\cs-\\cp\\spsi & \\sphi\\st\\spsi+\\cp\\cs & \\sphi\\ct \\\\ \\cp\\st\\cs+\\sphi\\spsi & \\cp\\st\\spsi-\\sphi\\cs & \\sphi\\st \\\\ \\end{bmatrix} \\end{equation} and converting back to euler angles is done via the following; \\begin{equation} \\begin{bmatrix} \\phi \\\\ \\theta \\\\ \\psi \\\\ \\end{bmatrix} = \\begin{bmatrix} \\textrm{atan2}\\left(R_{32}, R_{33}\\right) \\\\ \\textrm{atan2}\\left(-R_{31}, \\sqrt{R_{21}^2 + R_{33}^2}\\right) \\\\ \\textrm{atan2}\\left(R_{21}, R_{11}\\right) \\\\ \\end{bmatrix} \\end{equation} \\begin{equation} \\begin{bmatrix} \\phi \\\\ \\theta \\\\ \\psi \\\\ \\end{bmatrix} = \\begin{bmatrix} \\textrm{atan2}\\left(R_{32}, R_{33}\\right) \\\\ \\textrm{atan2}\\left(-R_{31}, \\sqrt{R_{21}^2 + R_{33}^2}\\right) \\\\ \\textrm{atan2}\\left(R_{21}, R_{11}\\right) \\\\ \\end{bmatrix} \\end{equation} Quaternions Quaternions are a number system which extends complex numbers. They have four elements, commonly known as w w , x x , y y , and z z . The last three elements can be though of as describing an axis, \\beta \\beta about which a rotation occurred, while the first element, w w can be though of as describing the amount of rotation \\alpha \\alpha about that axis. (see eq~\\ref{eq:euler_to_axis_angle}). While this may seem straight-forward, quaternions are normalized so that they can form a group. (That is, a quaternion multiplied by a quaternion is a quaternion), so they end up being really difficult for a human being to interpret just by looking at the values. However, they provide some amazing computational efficiencies, most of which comes from the following special mathematics associated with quaternions. First, just the definition of a quaternion: \\begin{equation} q = \\begin{bmatrix} q_w \\\\ q_x \\\\ q_y \\\\ q_z \\end{bmatrix} = \\begin{bmatrix} \\cos(\\alpha/2) \\\\ \\sin(\\alpha/2)\\cos(\\beta_x) \\\\ \\sin(\\alpha/2)\\cos(\\beta_y) \\\\ \\sin(\\alpha/2)\\cos(\\beta_y) \\end{bmatrix} = \\begin{bmatrix} s \\\\ v_x \\\\ v_y \\\\ v_z \\end{bmatrix} \\label{eq:euler_to_axis_angle} \\end{equation} \\begin{equation} q = \\begin{bmatrix} q_w \\\\ q_x \\\\ q_y \\\\ q_z \\end{bmatrix} = \\begin{bmatrix} \\cos(\\alpha/2) \\\\ \\sin(\\alpha/2)\\cos(\\beta_x) \\\\ \\sin(\\alpha/2)\\cos(\\beta_y) \\\\ \\sin(\\alpha/2)\\cos(\\beta_y) \\end{bmatrix} = \\begin{bmatrix} s \\\\ v_x \\\\ v_y \\\\ v_z \\end{bmatrix} \\label{eq:euler_to_axis_angle} \\end{equation} and second, some formulas to convert to and from euler angles. \\begin{equation} q = \\begin{bmatrix} \\cos(\\theta/2)\\cos(\\theta/2)\\cos(\\psi/2) + \\sin(\\phi/2)\\sin(\\theta/2)\\sin(\\psi/2) \\\\ \\sin(\\theta/2)\\cos(\\theta/2)\\cos(\\psi/2) - \\cos(\\phi/2)\\sin(\\theta/2)\\sin(\\psi/2) \\\\ \\cos(\\theta/2)\\sin(\\theta/2)\\cos(\\psi/2) + \\sin(\\phi/2)\\cos(\\theta/2)\\sin(\\psi/2) \\\\ \\cos(\\theta/2)\\cos(\\theta/2)\\sin(\\psi/2) - \\sin(\\phi/2)\\sin(\\theta/2)\\cos(\\psi/2) \\\\ \\end{bmatrix} \\end{equation} \\begin{equation} q = \\begin{bmatrix} \\cos(\\theta/2)\\cos(\\theta/2)\\cos(\\psi/2) + \\sin(\\phi/2)\\sin(\\theta/2)\\sin(\\psi/2) \\\\ \\sin(\\theta/2)\\cos(\\theta/2)\\cos(\\psi/2) - \\cos(\\phi/2)\\sin(\\theta/2)\\sin(\\psi/2) \\\\ \\cos(\\theta/2)\\sin(\\theta/2)\\cos(\\psi/2) + \\sin(\\phi/2)\\cos(\\theta/2)\\sin(\\psi/2) \\\\ \\cos(\\theta/2)\\cos(\\theta/2)\\sin(\\psi/2) - \\sin(\\phi/2)\\sin(\\theta/2)\\cos(\\psi/2) \\\\ \\end{bmatrix} \\end{equation} \\begin{equation} \\begin{bmatrix} \\phi \\\\ \\theta \\\\ \\psi \\\\ \\end{bmatrix} = \\begin{bmatrix} \\textrm{atan2}\\left( 2\\left(q_wq_x + q_yq_z\\right),1-2\\left(q_x^2+q_y^2\\right) \\right) \\\\ \\textrm{sin}^{-1}\\left( 2 \\left( q_wq_y - q_zq_x \\right) \\right) \\\\ \\textrm{atan2}\\left( 2 \\left( q_wq_z + q_xq_y \\right), 1 - 2 \\left( q_y^2 q_z^2 \\right) \\right) \\end{bmatrix} \\label{eq:euler_from_quat} \\tag{5} \\end{equation} \\begin{equation} \\begin{bmatrix} \\phi \\\\ \\theta \\\\ \\psi \\\\ \\end{bmatrix} = \\begin{bmatrix} \\textrm{atan2}\\left( 2\\left(q_wq_x + q_yq_z\\right),1-2\\left(q_x^2+q_y^2\\right) \\right) \\\\ \\textrm{sin}^{-1}\\left( 2 \\left( q_wq_y - q_zq_x \\right) \\right) \\\\ \\textrm{atan2}\\left( 2 \\left( q_wq_z + q_xq_y \\right), 1 - 2 \\left( q_y^2 q_z^2 \\right) \\right) \\end{bmatrix} \\label{eq:euler_from_quat} \\tag{5} \\end{equation} The quaternion group is \"closed\" under the following operation, termed quaternion multiplication. q_1 \\otimes q_2 = \\begin{bmatrix} s_1s_2 - v_1^\\top v_2 \\\\ s_1v_2 + s_2v_1 + v_1 \\times v_2 \\end{bmatrix} q_1 \\otimes q_2 = \\begin{bmatrix} s_1s_2 - v_1^\\top v_2 \\\\ s_1v_2 + s_2v_1 + v_1 \\times v_2 \\end{bmatrix} To take the \"inverse\" of a quaternion is simply to multiply s s or v v by -1 -1 \\begin{equation} q^{-1} = \\begin{bmatrix} -q_w \\\\ q_x \\\\ q_y \\\\ q_z \\end{bmatrix} = \\begin{bmatrix} q_w \\\\ -q_x \\\\ -q_y \\\\ -q_z \\end{bmatrix} \\end{equation} \\begin{equation} q^{-1} = \\begin{bmatrix} -q_w \\\\ q_x \\\\ q_y \\\\ q_z \\end{bmatrix} = \\begin{bmatrix} q_w \\\\ -q_x \\\\ -q_y \\\\ -q_z \\end{bmatrix} \\end{equation} and to find the difference between two quaternions, just quaternion multiply the inverse of one quaternion with the other. \\begin{equation} \\tilde{q} = \\hat{q}^{-1} \\otimes q \\end{equation} \\begin{equation} \\tilde{q} = \\hat{q}^{-1} \\otimes q \\end{equation} However, the most important aspect of quaternions is the way we propagate dynamics. \\begin{equation} \\dot{q} = \\frac{1}{2} q \\otimes q_\\omega \\end{equation} \\begin{equation} \\dot{q} = \\frac{1}{2} q \\otimes q_\\omega \\end{equation} where q_\\omega q_\\omega is the pure quaternion created from angular rates. \\begin{equation} q_\\omega = \\textrm{p}(\\omega) = \\begin{bmatrix} 0 \\\\ p \\\\ q \\\\ r \\end{bmatrix} \\end{equation} \\begin{equation} q_\\omega = \\textrm{p}(\\omega) = \\begin{bmatrix} 0 \\\\ p \\\\ q \\\\ r \\end{bmatrix} \\end{equation} What this means is that, like rotation matrices, quaternion dynamics are linear with respect to angular rates, as opposed to euler angles, which are non-linear, and they take less computation than rotation matrices because they have fewer terms. Casey et al. [Casey2013] performed a study comparing all three of the above representations, and found that complementary filters using an euler angle representation took 12 times longer to compute on average than a quaternion-based filter. Quaternions were also about 20% more efficient when compared with rotation matrices. For these reasons, ROSflight uses quaternions in its filter. Derivation ROSflight implements the quaternion-based passive \"Mahony\" filter as described in this paper 1 . In particular, we implement equation 47 from that paper, which also estimates gyroscope biases. A Lyuapanov stability analysis is performed in that paper, in which it is shown that all states and biases, except heading, are globally asymptotically stable given an accelerometer measurement and gyroscope. The above reference also describes how a magnetometer can be integrated in a similar method to the accelerometer. That portion of the filter is omitted here due to the unreliable nature of magnetometers on-board modern small UAS. Passive Complementary Filter The original filter propagates per the following dynamics: \\newcommand{\\werr}{\\omega_\\text{err}} \\newcommand{\\wfinal}{\\omega_\\text{final}} \\begin{equation} \\begin{aligned} \\dot{\\hat{q}} = \\frac{1}{2} \\hat{q} \\otimes \\textrm{p}\\left(\\wfinal\\right) \\\\ \\dot{\\hat{b}} = -2k_I\\werr \\end{aligned} \\label{eq:traditional_prop} \\tag{1} \\end{equation} \\newcommand{\\werr}{\\omega_\\text{err}} \\newcommand{\\wfinal}{\\omega_\\text{final}} \\begin{equation} \\begin{aligned} \\dot{\\hat{q}} &= \\frac{1}{2} \\hat{q} \\otimes \\textrm{p}\\left(\\wfinal\\right) \\\\ \\dot{\\hat{b}} &= -2k_I\\werr \\end{aligned} \\label{eq:traditional_prop} \\tag{1} \\end{equation} where \\textrm{p}\\left(\\cdot\\right) \\textrm{p}\\left(\\cdot\\right) creates a pure quaternion from a 3-vector. The term \\wfinal \\wfinal is a composite angular rate which consists of the measured angular rates, \\bar{\\omega} \\bar{\\omega} , the estimated gyroscope biases, \\hat{b} \\hat{b} , and a correction term calculated from another measurement of attitude (usually the accelerometer), \\werr \\werr . The constant gains k_p k_p and k_I k_I s are used in determining the dynamics of the filter. $$ \\begin{equation}\\label{eq:q_omega}\\tag{2} \\wfinal = \\bar{\\omega} - \\hat{b} + k_P\\werr \\end{equation} $$ \\newcommand{\\avec}{a} \\newcommand{\\gvec}{g} \\newcommand{\\qmeas}{q_{acc}} \\newcommand{\\gamvec}{\\gamma} \\newcommand{\\norm}[1]{\\left\\lVert#1\\right\\rVert} \\newcommand{\\wbar}{\\bar\\omega} \\newcommand{\\w}{\\omega} \\newcommand{\\qhat}{\\hat{q}} \\newcommand{\\avec}{a} \\newcommand{\\gvec}{g} \\newcommand{\\qmeas}{q_{acc}} \\newcommand{\\gamvec}{\\gamma} \\newcommand{\\norm}[1]{\\left\\lVert#1\\right\\rVert} \\newcommand{\\wbar}{\\bar\\omega} \\newcommand{\\w}{\\omega} \\newcommand{\\qhat}{\\hat{q}} The correction term \\werr \\werr can be understood as the error in the attitude as predicted by another source (e.g., the accelerometer). To calculate \\werr \\werr the quaternion describing the rotation between the accelerometer estimate and the z-axis of the inertial frame (i.e., where gravity should be), \\qmeas \\qmeas , is first calculated \\begin{equation} \\avec = \\begin{bmatrix} a_x \\\\ a_y \\\\ a_z \\\\ \\end{bmatrix}, \\qquad \\gvec = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ \\end{bmatrix}, \\qquad \\gamvec = \\frac{\\avec+\\gvec}{\\norm{\\avec+\\gvec}}, \\qquad \\qmeas = \\begin{bmatrix} \\avec^\\top \\gamvec \\\\ \\avec \\times \\gamvec \\end{bmatrix} \\end{equation} \\begin{equation} \\avec = \\begin{bmatrix} a_x \\\\ a_y \\\\ a_z \\\\ \\end{bmatrix}, \\qquad \\gvec = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ \\end{bmatrix}, \\qquad \\gamvec = \\frac{\\avec+\\gvec}{\\norm{\\avec+\\gvec}}, \\qquad \\qmeas = \\begin{bmatrix} \\avec^\\top \\gamvec \\\\ \\avec \\times \\gamvec \\end{bmatrix} \\end{equation} \\newcommand{\\qtilde}{\\tilde{q}} \\newcommand{\\vtilde}{\\tilde{v}} \\newcommand{\\qtilde}{\\tilde{q}} \\newcommand{\\vtilde}{\\tilde{v}} Next, the quaternion error between the estimate \\qhat \\qhat and the accelerometer measure \\qmeas \\qmeas is calculated. \\begin{equation} \\qtilde = \\qmeas^{-1} \\otimes \\qhat = \\begin{bmatrix} \\tilde{s}\\ \\vtilde \\end{bmatrix} \\end{equation} Finally, \\qmeas \\qmeas is converted back into a 3-vector per the method described in eq. 47a of Mahony2007 1 . \\begin{equation} \\werr = 2\\tilde{s}\\vtilde \\end{equation} Both the attitude quaternion and bias dynamics can be integrated using standard Euler integration, requiring that the resulting quaternion is re-normalized. Modifications to Original Passive Filter There have been a few modifications to the passive filter described in Mahony2007 1 , consisting primarily of contributions from Casey2013 . Firstly, rather than simply taking gyroscope measurements directly as an estimate of \\omega \\omega , a quadratic polynomial is used to approximate the true angular rate from gyroscope measurements to reduce error. In Casey2013, this process was shown to reduce RMS error by more than 1,000 times. There are additional steps associated with performing this calculation, but the benefit in accuracy more than compensates for the extra calculation time. The equation to perform this calculation is shown in Eq. \\eqref{eq:quad_approx} \\eqref{eq:quad_approx} . \\begin{equation} \\bar{\\omega} = \\frac{1}{12}\\left(-\\omega\\left(t_{n-2}\\right) + 8\\omega\\left(t_{n-1}\\right) + 5\\omega\\left(t_n\\right) \\right) \\label{eq:quad_approx} \\tag{4} \\end{equation} \\begin{equation} \\bar{\\omega} = \\frac{1}{12}\\left(-\\omega\\left(t_{n-2}\\right) + 8\\omega\\left(t_{n-1}\\right) + 5\\omega\\left(t_n\\right) \\right) \\label{eq:quad_approx} \\tag{4} \\end{equation} where \\omega(t_{n-x}) \\omega(t_{n-x}) is the gyroscope measurement of the angular rate x x measurements previous. The second modification is in the way that the attitude is propagated after finding \\dot{\\hat{q}} \\dot{\\hat{q}} . Instead of performing the standard euler integration \\begin{equation} \\hat{q}_n = \\hat{q}_{n-1}+\\dot{\\hat{q}}_n dt \\end{equation} \\begin{equation} \\hat{q}_n = \\hat{q}_{n-1}+\\dot{\\hat{q}}_n dt \\end{equation} we use an approximation of the matrix exponential. The matrix exponential arises out of the solution to the differential equation \\dot{x} = Ax \\dot{x} = Ax , namely $$ \\begin{equation} x(t) = e^{At} x(0) \\end{equation} $$ and the discrete-time equivalent $$ \\begin{equation} x(t_{n+1}) = e^{hA}(t_n) \\end{equation} $$ This discrete-time matrix exponential can be approximated by first expanding the matrix exponential into the infinite series \\begin{equation} e^{A} = \\sum_{k=0}^\\infty \\dfrac{1}{k!}A^k \\end{equation} \\begin{equation} e^{A} = \\sum_{k=0}^\\infty \\dfrac{1}{k!}A^k \\end{equation} and then grouping odd and even terms from the infinite series into two sinusoids, and results in the following equation for the propagation of the quaternion dynamics \\begin{equation} \\qhat(t_n) = \\left[ \\cos \\left( \\frac{\\norm{\\w}h}{2}\\right)I_4 + \\frac{1}{\\norm{\\w}} \\sin \\left( \\frac{\\norm{\\w}h}{2} \\right) \\lfloor\\w\\rfloor_4 \\right] \\qhat(t_{n-1}) \\label{eq:mat_exponential} \\tag{3} \\end{equation} \\begin{equation} \\qhat(t_n) = \\left[ \\cos \\left( \\frac{\\norm{\\w}h}{2}\\right)I_4 + \\frac{1}{\\norm{\\w}} \\sin \\left( \\frac{\\norm{\\w}h}{2} \\right) \\lfloor\\w\\rfloor_4 \\right] \\qhat(t_{n-1}) \\label{eq:mat_exponential} \\tag{3} \\end{equation} where \\lfloor\\w\\rfloor_4 \\lfloor\\w\\rfloor_4 is the 4x4 skew-symmetric matrix formed from \\w \\w \\begin{equation} \\lfloor\\w\\rfloor_4 = \\begin{bmatrix} 0 - p - q - r \\\\ p 0 r - q \\\\ q - r 0 p \\\\ r q - p 0 \\\\ \\end{bmatrix} \\end{equation} \\begin{equation} \\lfloor\\w\\rfloor_4 = \\begin{bmatrix} 0 & - p & - q & - r \\\\ p & 0 & r & - q \\\\ q & - r & 0 & p \\\\ r & q & - p & 0 \\\\ \\end{bmatrix} \\end{equation} External Attitude Measurements Using the ROSflight estimator with gyro measurements only will quickly drift due to gyro biases. The accelerometer makes the biases in p p and q q observable and provides another measurement of pitch and roll. To make yaw observable, an external attitude measurement can be provided to the estimator which is used in much the same way as the accelerometer. Instead of as outlined above for accelerometer updates, the correction term \\werr \\werr can be calculated as $$ \\begin{equation} \\werr = k_\\text{ext}\\sum_{i=1}^3 R(\\hat{q})^\\top e_i\\times \\bar{R}^\\top e_i \\end{equation} $$ where k_\\text{ext}= F_s^\\text{IMU} / F_s^\\text{ext} k_\\text{ext}= F_s^\\text{IMU} / F_s^\\text{ext} is the ratio of the IMU sample rate to the external attitude sample rate. In our implementation, whenever an external attitude measurement is supplied, if there was a \\werr \\werr calculated from the accelerometer, it is overwritten by the above calculation for an external attitude update. Also note that the gain k_P k_P associated with an external attitude can be much higher if we trust the source of the external attitude measurement. Tuning The filter can be tuned with the two gains k_P k_P and k_I k_I . Upon initialization, k_P k_P and k_i k_i are set very high, so as to quickly cause the filter to converge upon approprate values. After a few seconds, they are both reduced by a factor of 10, to a value chosen through manual tuning. A high k_P k_P will cause sensitivity to transient accelerometer errors, while a small k_P k_P will cause sensitivity to gyroscope drift. A high k_I k_I will cause biases to wander unnecessarily, while a low k_I k_I will result in slow convergence upon accurate gyroscope bias estimates. These parameters generally do not need to be modified from the default values. Implementation The entire filter is implemented in float-based quaternion calculations. Even though the STM32F10x microprocessor does not contain a floating-point unit, the entire filter has been timed to take about 370 \\mu \\mu s. The extra steps of quadratic integration and matrix exponential propagation can be ommited for a 20 \\mu \\mu s and 90 \\mu \\mu s reduction in speed, respectively. Even with these functions, however, this is sufficiently short to run at well over 1000Hz, which is the update rate of the MPU6050 on the naze32. Control is performed according to euler angle estimates, and to reduce the computational load of converting from quaternion to euler angles (See Equation \\eqref{eq:euler_from_quat} \\eqref{eq:euler_from_quat} ), a lookup table approximation of atan2 and asin are used. The Invensense MPU6050 has a 16-bit ADC and an accelerometer and gyro onboard. The accelerometer, when scaled to \\pm \\pm 4g, has a resolution of 0.002394 m/s ^2 ^2 . The lookup table method used to approximate atan2 and asin in the actual implementation is accurate to \\pm \\pm 0.001 rad. Given the accuracy of the accelerometer, use of this lookup table implementation is justfied. The C-code implementation of the estimator can be found in the file src/estimator.c. Mahony, R., Hamel, T. and Pflimlin, J. (2008). Nonlinear Complementary Filters on the Special Orthogonal Group. IEEE Transactions on Automatic Control, 53(5), pp.1203-1218.","title":"Estimator"},{"location":"algorithms/estimator/#estimator","text":"","title":"Estimator"},{"location":"algorithms/estimator/#introduction","text":"The estimator is used to calculate an estimate of the attitude and angular velocity of the multirotor. It is assumed that the flight controller is mounted rigidly to the body of the aircraft (perhaps with dampening material to remove vibrations from the motors), such that measurements of the on-board IMU are consistent with the motion of the aircraft. Due to the limited computational power on the embedded processor, and to calculate attitude estimates at speeds up to 8000Hz, a simple complementary filter is used, rather than an extended Kalman filter. In practice, this method works extremely well, and it used widely throughout commercially available autopilots. There are a variety of complementary filters, but the general theory is the same. A complementary filter is a method that combines low and high frequency data (complementary in frequency bandwidth). It can be used to fuse the measurements from a gyroscope, accelerometer and sometimes magnetometer to produce an estimate of the attitude of the MAV.","title":"Introduction"},{"location":"algorithms/estimator/#complementary-filtering","text":"The idea behind complementary filtering is to try to get the \"best of both worlds\" of gyros and accelerometers. Gyros are very accurate in short spaces of time, but they are subject to low-frequency drift. Accelerometers don't drift in the long scheme of things, but they experience high-frequency noise as the MAV moves about. So, to solve these problems, the complementary filter primarily propagates states using gyroscope measurements, but then corrects drift with the accelerometer, which is a partial source of attitude measurements. In a general sense, it is like taking a high-pass filtered version of gyroscope measurements, and a low-pass filtered version of accelerometers, and fusing the two together in a manner that results in an estimate that is stable over time, but also able to handle quick transient motions. For an excellent review of the theory of complementary filtering, consult Mahony's Nonlinear Complementary Filtering on SO(3) paper 1 .","title":"Complementary Filtering"},{"location":"algorithms/estimator/#attitude-representation","text":"There are a number of ways to represent the attitude of a MAV. Often, attitude is represented in terms of the Euler angles yaw, pitch and roll, but it can also be represented in other ways, such as rotation matrices, and quaternions.","title":"Attitude Representation"},{"location":"algorithms/estimator/#euler-angles","text":"Euler angles represent rotations about three different axes, usually, the z, y, and x axes in that order. This method is often the most easy for users to understand and interpret, but it is by far the least computationally efficient. To propagate euler angles, the following kinematics are employed: \\begin{equation} \\begin{bmatrix} \\dot{\\phi} \\\\ \\dot{\\theta} \\\\ \\dot{\\psi} \\\\ \\end{bmatrix} = \\begin{bmatrix} 1 \\sin(\\phi) \\tan(\\theta) \\cos(\\phi)\\tan(\\theta) \\\\ 0 \\cos(\\phi) -\\sin(\\phi) \\\\ 0 \\frac{\\sin(\\phi)}{\\cos(\\theta)} \\frac{\\cos(\\phi)}{\\cos(\\theta)} \\\\ \\end{bmatrix} \\begin{bmatrix} p \\\\ q \\\\ r \\\\ \\end{bmatrix} \\end{equation} \\begin{equation} \\begin{bmatrix} \\dot{\\phi} \\\\ \\dot{\\theta} \\\\ \\dot{\\psi} \\\\ \\end{bmatrix} = \\begin{bmatrix} 1 & \\sin(\\phi) \\tan(\\theta) & \\cos(\\phi)\\tan(\\theta) \\\\ 0 & \\cos(\\phi) & -\\sin(\\phi) \\\\ 0 & \\frac{\\sin(\\phi)}{\\cos(\\theta)} & \\frac{\\cos(\\phi)}{\\cos(\\theta)} \\\\ \\end{bmatrix} \\begin{bmatrix} p \\\\ q \\\\ r \\\\ \\end{bmatrix} \\end{equation} Note the large number of trigonometric functions associated with this propagation. In a complementary filter, this will be evaluated at every measurement, and the non-linear coupling between \\omega \\omega and the attitude becomes very expensive, particularly on embedded processors. Another shortcoming of euler angles is known as \"gimbal lock\". Gimbal lock occurs at the \"singularity\" of the euler angle representation, or pitched directly up or down. The problem occurs because there is more than one way to represent this particular rotation. There are some steps one can take to handle these issues, but it is a fundamental problem associated with using euler angles, and motivates the other attitude representations.","title":"Euler Angles"},{"location":"algorithms/estimator/#rotation-matrix","text":"Rotation matrices, are often used in attitude estimation, because they do not suffer from gimbal lock, are quickly converted to and from euler angles, and because of their simple kinematics. \\begin{equation} \\dot{R} = \\lfloor\\omega\\rfloor R \\end{equation} \\begin{equation} \\dot{R} = \\lfloor\\omega\\rfloor R \\end{equation} where \\lfloor\\omega\\rfloor \\lfloor\\omega\\rfloor is the skew-symmetric matrix of \\omega \\omega , and is related to calculating the cross product. \\begin{equation} \\lfloor\\omega\\rfloor = \\begin{bmatrix} 0 -r q \\\\ r 0 -p \\\\ -q p 0 \\end{bmatrix} \\end{equation} \\begin{equation} \\lfloor\\omega\\rfloor = \\begin{bmatrix} 0 & -r & q \\\\ r & 0 & -p \\\\ -q & p & 0 \\end{bmatrix} \\end{equation} This propagation step is linear with respect to the angular rates, which simplifies calculation significantly. A rotation matrix from the inertial frame to body frame can be constructed from euler angles via the following formula: \\newcommand{\\ct}{c\\theta} \\newcommand{\\cp}{c\\phi} \\newcommand{\\cs}{c\\psi} \\newcommand{\\st}{s\\theta} \\newcommand{\\sphi}{s\\phi} \\newcommand{\\spsi}{s\\psi} \\begin{equation} R = \\begin{bmatrix} \\ct\\cs \\ct\\spsi -\\st \\\\ \\sphi\\st\\cs-\\cp\\spsi \\sphi\\st\\spsi+\\cp\\cs \\sphi\\ct \\\\ \\cp\\st\\cs+\\sphi\\spsi \\cp\\st\\spsi-\\sphi\\cs \\sphi\\st \\\\ \\end{bmatrix} \\end{equation} \\newcommand{\\ct}{c\\theta} \\newcommand{\\cp}{c\\phi} \\newcommand{\\cs}{c\\psi} \\newcommand{\\st}{s\\theta} \\newcommand{\\sphi}{s\\phi} \\newcommand{\\spsi}{s\\psi} \\begin{equation} R = \\begin{bmatrix} \\ct\\cs & \\ct\\spsi & -\\st \\\\ \\sphi\\st\\cs-\\cp\\spsi & \\sphi\\st\\spsi+\\cp\\cs & \\sphi\\ct \\\\ \\cp\\st\\cs+\\sphi\\spsi & \\cp\\st\\spsi-\\sphi\\cs & \\sphi\\st \\\\ \\end{bmatrix} \\end{equation} and converting back to euler angles is done via the following; \\begin{equation} \\begin{bmatrix} \\phi \\\\ \\theta \\\\ \\psi \\\\ \\end{bmatrix} = \\begin{bmatrix} \\textrm{atan2}\\left(R_{32}, R_{33}\\right) \\\\ \\textrm{atan2}\\left(-R_{31}, \\sqrt{R_{21}^2 + R_{33}^2}\\right) \\\\ \\textrm{atan2}\\left(R_{21}, R_{11}\\right) \\\\ \\end{bmatrix} \\end{equation} \\begin{equation} \\begin{bmatrix} \\phi \\\\ \\theta \\\\ \\psi \\\\ \\end{bmatrix} = \\begin{bmatrix} \\textrm{atan2}\\left(R_{32}, R_{33}\\right) \\\\ \\textrm{atan2}\\left(-R_{31}, \\sqrt{R_{21}^2 + R_{33}^2}\\right) \\\\ \\textrm{atan2}\\left(R_{21}, R_{11}\\right) \\\\ \\end{bmatrix} \\end{equation}","title":"Rotation Matrix"},{"location":"algorithms/estimator/#quaternions","text":"Quaternions are a number system which extends complex numbers. They have four elements, commonly known as w w , x x , y y , and z z . The last three elements can be though of as describing an axis, \\beta \\beta about which a rotation occurred, while the first element, w w can be though of as describing the amount of rotation \\alpha \\alpha about that axis. (see eq~\\ref{eq:euler_to_axis_angle}). While this may seem straight-forward, quaternions are normalized so that they can form a group. (That is, a quaternion multiplied by a quaternion is a quaternion), so they end up being really difficult for a human being to interpret just by looking at the values. However, they provide some amazing computational efficiencies, most of which comes from the following special mathematics associated with quaternions. First, just the definition of a quaternion: \\begin{equation} q = \\begin{bmatrix} q_w \\\\ q_x \\\\ q_y \\\\ q_z \\end{bmatrix} = \\begin{bmatrix} \\cos(\\alpha/2) \\\\ \\sin(\\alpha/2)\\cos(\\beta_x) \\\\ \\sin(\\alpha/2)\\cos(\\beta_y) \\\\ \\sin(\\alpha/2)\\cos(\\beta_y) \\end{bmatrix} = \\begin{bmatrix} s \\\\ v_x \\\\ v_y \\\\ v_z \\end{bmatrix} \\label{eq:euler_to_axis_angle} \\end{equation} \\begin{equation} q = \\begin{bmatrix} q_w \\\\ q_x \\\\ q_y \\\\ q_z \\end{bmatrix} = \\begin{bmatrix} \\cos(\\alpha/2) \\\\ \\sin(\\alpha/2)\\cos(\\beta_x) \\\\ \\sin(\\alpha/2)\\cos(\\beta_y) \\\\ \\sin(\\alpha/2)\\cos(\\beta_y) \\end{bmatrix} = \\begin{bmatrix} s \\\\ v_x \\\\ v_y \\\\ v_z \\end{bmatrix} \\label{eq:euler_to_axis_angle} \\end{equation} and second, some formulas to convert to and from euler angles. \\begin{equation} q = \\begin{bmatrix} \\cos(\\theta/2)\\cos(\\theta/2)\\cos(\\psi/2) + \\sin(\\phi/2)\\sin(\\theta/2)\\sin(\\psi/2) \\\\ \\sin(\\theta/2)\\cos(\\theta/2)\\cos(\\psi/2) - \\cos(\\phi/2)\\sin(\\theta/2)\\sin(\\psi/2) \\\\ \\cos(\\theta/2)\\sin(\\theta/2)\\cos(\\psi/2) + \\sin(\\phi/2)\\cos(\\theta/2)\\sin(\\psi/2) \\\\ \\cos(\\theta/2)\\cos(\\theta/2)\\sin(\\psi/2) - \\sin(\\phi/2)\\sin(\\theta/2)\\cos(\\psi/2) \\\\ \\end{bmatrix} \\end{equation} \\begin{equation} q = \\begin{bmatrix} \\cos(\\theta/2)\\cos(\\theta/2)\\cos(\\psi/2) + \\sin(\\phi/2)\\sin(\\theta/2)\\sin(\\psi/2) \\\\ \\sin(\\theta/2)\\cos(\\theta/2)\\cos(\\psi/2) - \\cos(\\phi/2)\\sin(\\theta/2)\\sin(\\psi/2) \\\\ \\cos(\\theta/2)\\sin(\\theta/2)\\cos(\\psi/2) + \\sin(\\phi/2)\\cos(\\theta/2)\\sin(\\psi/2) \\\\ \\cos(\\theta/2)\\cos(\\theta/2)\\sin(\\psi/2) - \\sin(\\phi/2)\\sin(\\theta/2)\\cos(\\psi/2) \\\\ \\end{bmatrix} \\end{equation} \\begin{equation} \\begin{bmatrix} \\phi \\\\ \\theta \\\\ \\psi \\\\ \\end{bmatrix} = \\begin{bmatrix} \\textrm{atan2}\\left( 2\\left(q_wq_x + q_yq_z\\right),1-2\\left(q_x^2+q_y^2\\right) \\right) \\\\ \\textrm{sin}^{-1}\\left( 2 \\left( q_wq_y - q_zq_x \\right) \\right) \\\\ \\textrm{atan2}\\left( 2 \\left( q_wq_z + q_xq_y \\right), 1 - 2 \\left( q_y^2 q_z^2 \\right) \\right) \\end{bmatrix} \\label{eq:euler_from_quat} \\tag{5} \\end{equation} \\begin{equation} \\begin{bmatrix} \\phi \\\\ \\theta \\\\ \\psi \\\\ \\end{bmatrix} = \\begin{bmatrix} \\textrm{atan2}\\left( 2\\left(q_wq_x + q_yq_z\\right),1-2\\left(q_x^2+q_y^2\\right) \\right) \\\\ \\textrm{sin}^{-1}\\left( 2 \\left( q_wq_y - q_zq_x \\right) \\right) \\\\ \\textrm{atan2}\\left( 2 \\left( q_wq_z + q_xq_y \\right), 1 - 2 \\left( q_y^2 q_z^2 \\right) \\right) \\end{bmatrix} \\label{eq:euler_from_quat} \\tag{5} \\end{equation} The quaternion group is \"closed\" under the following operation, termed quaternion multiplication. q_1 \\otimes q_2 = \\begin{bmatrix} s_1s_2 - v_1^\\top v_2 \\\\ s_1v_2 + s_2v_1 + v_1 \\times v_2 \\end{bmatrix} q_1 \\otimes q_2 = \\begin{bmatrix} s_1s_2 - v_1^\\top v_2 \\\\ s_1v_2 + s_2v_1 + v_1 \\times v_2 \\end{bmatrix} To take the \"inverse\" of a quaternion is simply to multiply s s or v v by -1 -1 \\begin{equation} q^{-1} = \\begin{bmatrix} -q_w \\\\ q_x \\\\ q_y \\\\ q_z \\end{bmatrix} = \\begin{bmatrix} q_w \\\\ -q_x \\\\ -q_y \\\\ -q_z \\end{bmatrix} \\end{equation} \\begin{equation} q^{-1} = \\begin{bmatrix} -q_w \\\\ q_x \\\\ q_y \\\\ q_z \\end{bmatrix} = \\begin{bmatrix} q_w \\\\ -q_x \\\\ -q_y \\\\ -q_z \\end{bmatrix} \\end{equation} and to find the difference between two quaternions, just quaternion multiply the inverse of one quaternion with the other. \\begin{equation} \\tilde{q} = \\hat{q}^{-1} \\otimes q \\end{equation} \\begin{equation} \\tilde{q} = \\hat{q}^{-1} \\otimes q \\end{equation} However, the most important aspect of quaternions is the way we propagate dynamics. \\begin{equation} \\dot{q} = \\frac{1}{2} q \\otimes q_\\omega \\end{equation} \\begin{equation} \\dot{q} = \\frac{1}{2} q \\otimes q_\\omega \\end{equation} where q_\\omega q_\\omega is the pure quaternion created from angular rates. \\begin{equation} q_\\omega = \\textrm{p}(\\omega) = \\begin{bmatrix} 0 \\\\ p \\\\ q \\\\ r \\end{bmatrix} \\end{equation} \\begin{equation} q_\\omega = \\textrm{p}(\\omega) = \\begin{bmatrix} 0 \\\\ p \\\\ q \\\\ r \\end{bmatrix} \\end{equation} What this means is that, like rotation matrices, quaternion dynamics are linear with respect to angular rates, as opposed to euler angles, which are non-linear, and they take less computation than rotation matrices because they have fewer terms. Casey et al. [Casey2013] performed a study comparing all three of the above representations, and found that complementary filters using an euler angle representation took 12 times longer to compute on average than a quaternion-based filter. Quaternions were also about 20% more efficient when compared with rotation matrices. For these reasons, ROSflight uses quaternions in its filter.","title":"Quaternions"},{"location":"algorithms/estimator/#derivation","text":"ROSflight implements the quaternion-based passive \"Mahony\" filter as described in this paper 1 . In particular, we implement equation 47 from that paper, which also estimates gyroscope biases. A Lyuapanov stability analysis is performed in that paper, in which it is shown that all states and biases, except heading, are globally asymptotically stable given an accelerometer measurement and gyroscope. The above reference also describes how a magnetometer can be integrated in a similar method to the accelerometer. That portion of the filter is omitted here due to the unreliable nature of magnetometers on-board modern small UAS.","title":"Derivation"},{"location":"algorithms/estimator/#passive-complementary-filter","text":"The original filter propagates per the following dynamics: \\newcommand{\\werr}{\\omega_\\text{err}} \\newcommand{\\wfinal}{\\omega_\\text{final}} \\begin{equation} \\begin{aligned} \\dot{\\hat{q}} = \\frac{1}{2} \\hat{q} \\otimes \\textrm{p}\\left(\\wfinal\\right) \\\\ \\dot{\\hat{b}} = -2k_I\\werr \\end{aligned} \\label{eq:traditional_prop} \\tag{1} \\end{equation} \\newcommand{\\werr}{\\omega_\\text{err}} \\newcommand{\\wfinal}{\\omega_\\text{final}} \\begin{equation} \\begin{aligned} \\dot{\\hat{q}} &= \\frac{1}{2} \\hat{q} \\otimes \\textrm{p}\\left(\\wfinal\\right) \\\\ \\dot{\\hat{b}} &= -2k_I\\werr \\end{aligned} \\label{eq:traditional_prop} \\tag{1} \\end{equation} where \\textrm{p}\\left(\\cdot\\right) \\textrm{p}\\left(\\cdot\\right) creates a pure quaternion from a 3-vector. The term \\wfinal \\wfinal is a composite angular rate which consists of the measured angular rates, \\bar{\\omega} \\bar{\\omega} , the estimated gyroscope biases, \\hat{b} \\hat{b} , and a correction term calculated from another measurement of attitude (usually the accelerometer), \\werr \\werr . The constant gains k_p k_p and k_I k_I s are used in determining the dynamics of the filter. $$ \\begin{equation}\\label{eq:q_omega}\\tag{2} \\wfinal = \\bar{\\omega} - \\hat{b} + k_P\\werr \\end{equation} $$ \\newcommand{\\avec}{a} \\newcommand{\\gvec}{g} \\newcommand{\\qmeas}{q_{acc}} \\newcommand{\\gamvec}{\\gamma} \\newcommand{\\norm}[1]{\\left\\lVert#1\\right\\rVert} \\newcommand{\\wbar}{\\bar\\omega} \\newcommand{\\w}{\\omega} \\newcommand{\\qhat}{\\hat{q}} \\newcommand{\\avec}{a} \\newcommand{\\gvec}{g} \\newcommand{\\qmeas}{q_{acc}} \\newcommand{\\gamvec}{\\gamma} \\newcommand{\\norm}[1]{\\left\\lVert#1\\right\\rVert} \\newcommand{\\wbar}{\\bar\\omega} \\newcommand{\\w}{\\omega} \\newcommand{\\qhat}{\\hat{q}} The correction term \\werr \\werr can be understood as the error in the attitude as predicted by another source (e.g., the accelerometer). To calculate \\werr \\werr the quaternion describing the rotation between the accelerometer estimate and the z-axis of the inertial frame (i.e., where gravity should be), \\qmeas \\qmeas , is first calculated \\begin{equation} \\avec = \\begin{bmatrix} a_x \\\\ a_y \\\\ a_z \\\\ \\end{bmatrix}, \\qquad \\gvec = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ \\end{bmatrix}, \\qquad \\gamvec = \\frac{\\avec+\\gvec}{\\norm{\\avec+\\gvec}}, \\qquad \\qmeas = \\begin{bmatrix} \\avec^\\top \\gamvec \\\\ \\avec \\times \\gamvec \\end{bmatrix} \\end{equation} \\begin{equation} \\avec = \\begin{bmatrix} a_x \\\\ a_y \\\\ a_z \\\\ \\end{bmatrix}, \\qquad \\gvec = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ \\end{bmatrix}, \\qquad \\gamvec = \\frac{\\avec+\\gvec}{\\norm{\\avec+\\gvec}}, \\qquad \\qmeas = \\begin{bmatrix} \\avec^\\top \\gamvec \\\\ \\avec \\times \\gamvec \\end{bmatrix} \\end{equation} \\newcommand{\\qtilde}{\\tilde{q}} \\newcommand{\\vtilde}{\\tilde{v}} \\newcommand{\\qtilde}{\\tilde{q}} \\newcommand{\\vtilde}{\\tilde{v}} Next, the quaternion error between the estimate \\qhat \\qhat and the accelerometer measure \\qmeas \\qmeas is calculated. \\begin{equation} \\qtilde = \\qmeas^{-1} \\otimes \\qhat = \\begin{bmatrix} \\tilde{s}\\ \\vtilde \\end{bmatrix} \\end{equation} Finally, \\qmeas \\qmeas is converted back into a 3-vector per the method described in eq. 47a of Mahony2007 1 . \\begin{equation} \\werr = 2\\tilde{s}\\vtilde \\end{equation} Both the attitude quaternion and bias dynamics can be integrated using standard Euler integration, requiring that the resulting quaternion is re-normalized.","title":"Passive Complementary Filter"},{"location":"algorithms/estimator/#modifications-to-original-passive-filter","text":"There have been a few modifications to the passive filter described in Mahony2007 1 , consisting primarily of contributions from Casey2013 . Firstly, rather than simply taking gyroscope measurements directly as an estimate of \\omega \\omega , a quadratic polynomial is used to approximate the true angular rate from gyroscope measurements to reduce error. In Casey2013, this process was shown to reduce RMS error by more than 1,000 times. There are additional steps associated with performing this calculation, but the benefit in accuracy more than compensates for the extra calculation time. The equation to perform this calculation is shown in Eq. \\eqref{eq:quad_approx} \\eqref{eq:quad_approx} . \\begin{equation} \\bar{\\omega} = \\frac{1}{12}\\left(-\\omega\\left(t_{n-2}\\right) + 8\\omega\\left(t_{n-1}\\right) + 5\\omega\\left(t_n\\right) \\right) \\label{eq:quad_approx} \\tag{4} \\end{equation} \\begin{equation} \\bar{\\omega} = \\frac{1}{12}\\left(-\\omega\\left(t_{n-2}\\right) + 8\\omega\\left(t_{n-1}\\right) + 5\\omega\\left(t_n\\right) \\right) \\label{eq:quad_approx} \\tag{4} \\end{equation} where \\omega(t_{n-x}) \\omega(t_{n-x}) is the gyroscope measurement of the angular rate x x measurements previous. The second modification is in the way that the attitude is propagated after finding \\dot{\\hat{q}} \\dot{\\hat{q}} . Instead of performing the standard euler integration \\begin{equation} \\hat{q}_n = \\hat{q}_{n-1}+\\dot{\\hat{q}}_n dt \\end{equation} \\begin{equation} \\hat{q}_n = \\hat{q}_{n-1}+\\dot{\\hat{q}}_n dt \\end{equation} we use an approximation of the matrix exponential. The matrix exponential arises out of the solution to the differential equation \\dot{x} = Ax \\dot{x} = Ax , namely $$ \\begin{equation} x(t) = e^{At} x(0) \\end{equation} $$ and the discrete-time equivalent $$ \\begin{equation} x(t_{n+1}) = e^{hA}(t_n) \\end{equation} $$ This discrete-time matrix exponential can be approximated by first expanding the matrix exponential into the infinite series \\begin{equation} e^{A} = \\sum_{k=0}^\\infty \\dfrac{1}{k!}A^k \\end{equation} \\begin{equation} e^{A} = \\sum_{k=0}^\\infty \\dfrac{1}{k!}A^k \\end{equation} and then grouping odd and even terms from the infinite series into two sinusoids, and results in the following equation for the propagation of the quaternion dynamics \\begin{equation} \\qhat(t_n) = \\left[ \\cos \\left( \\frac{\\norm{\\w}h}{2}\\right)I_4 + \\frac{1}{\\norm{\\w}} \\sin \\left( \\frac{\\norm{\\w}h}{2} \\right) \\lfloor\\w\\rfloor_4 \\right] \\qhat(t_{n-1}) \\label{eq:mat_exponential} \\tag{3} \\end{equation} \\begin{equation} \\qhat(t_n) = \\left[ \\cos \\left( \\frac{\\norm{\\w}h}{2}\\right)I_4 + \\frac{1}{\\norm{\\w}} \\sin \\left( \\frac{\\norm{\\w}h}{2} \\right) \\lfloor\\w\\rfloor_4 \\right] \\qhat(t_{n-1}) \\label{eq:mat_exponential} \\tag{3} \\end{equation} where \\lfloor\\w\\rfloor_4 \\lfloor\\w\\rfloor_4 is the 4x4 skew-symmetric matrix formed from \\w \\w \\begin{equation} \\lfloor\\w\\rfloor_4 = \\begin{bmatrix} 0 - p - q - r \\\\ p 0 r - q \\\\ q - r 0 p \\\\ r q - p 0 \\\\ \\end{bmatrix} \\end{equation} \\begin{equation} \\lfloor\\w\\rfloor_4 = \\begin{bmatrix} 0 & - p & - q & - r \\\\ p & 0 & r & - q \\\\ q & - r & 0 & p \\\\ r & q & - p & 0 \\\\ \\end{bmatrix} \\end{equation}","title":"Modifications to Original Passive Filter"},{"location":"algorithms/estimator/#external-attitude-measurements","text":"Using the ROSflight estimator with gyro measurements only will quickly drift due to gyro biases. The accelerometer makes the biases in p p and q q observable and provides another measurement of pitch and roll. To make yaw observable, an external attitude measurement can be provided to the estimator which is used in much the same way as the accelerometer. Instead of as outlined above for accelerometer updates, the correction term \\werr \\werr can be calculated as $$ \\begin{equation} \\werr = k_\\text{ext}\\sum_{i=1}^3 R(\\hat{q})^\\top e_i\\times \\bar{R}^\\top e_i \\end{equation} $$ where k_\\text{ext}= F_s^\\text{IMU} / F_s^\\text{ext} k_\\text{ext}= F_s^\\text{IMU} / F_s^\\text{ext} is the ratio of the IMU sample rate to the external attitude sample rate. In our implementation, whenever an external attitude measurement is supplied, if there was a \\werr \\werr calculated from the accelerometer, it is overwritten by the above calculation for an external attitude update. Also note that the gain k_P k_P associated with an external attitude can be much higher if we trust the source of the external attitude measurement.","title":"External Attitude Measurements"},{"location":"algorithms/estimator/#tuning","text":"The filter can be tuned with the two gains k_P k_P and k_I k_I . Upon initialization, k_P k_P and k_i k_i are set very high, so as to quickly cause the filter to converge upon approprate values. After a few seconds, they are both reduced by a factor of 10, to a value chosen through manual tuning. A high k_P k_P will cause sensitivity to transient accelerometer errors, while a small k_P k_P will cause sensitivity to gyroscope drift. A high k_I k_I will cause biases to wander unnecessarily, while a low k_I k_I will result in slow convergence upon accurate gyroscope bias estimates. These parameters generally do not need to be modified from the default values.","title":"Tuning"},{"location":"algorithms/estimator/#implementation","text":"The entire filter is implemented in float-based quaternion calculations. Even though the STM32F10x microprocessor does not contain a floating-point unit, the entire filter has been timed to take about 370 \\mu \\mu s. The extra steps of quadratic integration and matrix exponential propagation can be ommited for a 20 \\mu \\mu s and 90 \\mu \\mu s reduction in speed, respectively. Even with these functions, however, this is sufficiently short to run at well over 1000Hz, which is the update rate of the MPU6050 on the naze32. Control is performed according to euler angle estimates, and to reduce the computational load of converting from quaternion to euler angles (See Equation \\eqref{eq:euler_from_quat} \\eqref{eq:euler_from_quat} ), a lookup table approximation of atan2 and asin are used. The Invensense MPU6050 has a 16-bit ADC and an accelerometer and gyro onboard. The accelerometer, when scaled to \\pm \\pm 4g, has a resolution of 0.002394 m/s ^2 ^2 . The lookup table method used to approximate atan2 and asin in the actual implementation is accurate to \\pm \\pm 0.001 rad. Given the accuracy of the accelerometer, use of this lookup table implementation is justfied. The C-code implementation of the estimator can be found in the file src/estimator.c. Mahony, R., Hamel, T. and Pflimlin, J. (2008). Nonlinear Complementary Filters on the Special Orthogonal Group. IEEE Transactions on Automatic Control, 53(5), pp.1203-1218.","title":"Implementation"},{"location":"developer-guide/building-flashing/","text":"Building and Flashing the Firmware Warning Deprecation Notice: As of June 2019, plans are to deprecate support for the F1 in the near future. If you need to use an F1, you will need to retrieve an older version of the code that supports the F1. However, if there are issues, we will not be able to help you fix them. Installing the ARM Embedded Toolchain To build the firmware, you will need a supported version of the ARM embedded toolchain (the compiler). If you are running Ubuntu on an ARM computer, you can simply install gcc with apt . Otherwise, you will need to manually install the ARM gcc compiler. Currently (as of June 2019), we are targeting version 6.3.1 of the \"gcc-arm-none-eabi\" compiler provided by the 6-2017-q2-update . Install this version of the toolchain by downloading the archive from the ARM website and extracting to your /opt directory: wget https://developer.arm.com/-/media/Files/downloads/gnu-rm/6-2017q2/gcc-arm-none-eabi-6-2017-q2-update-linux.tar.bz2 tar -C /opt -xf gcc-arm-none-eabi-6-2017-q2-update-linux.tar.bz2 Add the following line to ~/.bashrc (or your equivalent) to add the toolchain to your path: export PATH = $PATH :/opt/gcc-arm-none-eabi-6-2017-q2-update/bin You can test the installation and check which version is installed by running arm-none-eabi-gcc --version . Building the Firmware from Source Now that we have the compiler installed, simply clone the ROSflight firmware repository, pull down the submodules, and build: git clone https://github.com/rosflight/firmware cd firmware git submodule update --init --recursive make To build only the F4 firmware, use make BOARD=REVO . To build only the F1 firmware, use make BOARD=NAZE . Flashing Newly-Built Firmware First, make sure you have configured your computer as described in the Serial Port Configuration section of the user guide. F4 Flash the firmware to the board by running make BOARD=REVO flash . If necessary, specify the serial port with make BOARD=REVO SERIAL_DEVICE=/dev/ttyACM0 flash . F1 Flash the firmware to the board by running make BOARD=NAZE flash If necessary, specify the serial port with make BOARD=REVO SERIAL_DEVICE=/dev/ttyUSB0 flash .","title":"Building and Flashing"},{"location":"developer-guide/building-flashing/#building-and-flashing-the-firmware","text":"Warning Deprecation Notice: As of June 2019, plans are to deprecate support for the F1 in the near future. If you need to use an F1, you will need to retrieve an older version of the code that supports the F1. However, if there are issues, we will not be able to help you fix them.","title":"Building and Flashing the Firmware"},{"location":"developer-guide/building-flashing/#installing-the-arm-embedded-toolchain","text":"To build the firmware, you will need a supported version of the ARM embedded toolchain (the compiler). If you are running Ubuntu on an ARM computer, you can simply install gcc with apt . Otherwise, you will need to manually install the ARM gcc compiler. Currently (as of June 2019), we are targeting version 6.3.1 of the \"gcc-arm-none-eabi\" compiler provided by the 6-2017-q2-update . Install this version of the toolchain by downloading the archive from the ARM website and extracting to your /opt directory: wget https://developer.arm.com/-/media/Files/downloads/gnu-rm/6-2017q2/gcc-arm-none-eabi-6-2017-q2-update-linux.tar.bz2 tar -C /opt -xf gcc-arm-none-eabi-6-2017-q2-update-linux.tar.bz2 Add the following line to ~/.bashrc (or your equivalent) to add the toolchain to your path: export PATH = $PATH :/opt/gcc-arm-none-eabi-6-2017-q2-update/bin You can test the installation and check which version is installed by running arm-none-eabi-gcc --version .","title":"Installing the ARM Embedded Toolchain"},{"location":"developer-guide/building-flashing/#building-the-firmware-from-source","text":"Now that we have the compiler installed, simply clone the ROSflight firmware repository, pull down the submodules, and build: git clone https://github.com/rosflight/firmware cd firmware git submodule update --init --recursive make To build only the F4 firmware, use make BOARD=REVO . To build only the F1 firmware, use make BOARD=NAZE .","title":"Building the Firmware from Source"},{"location":"developer-guide/building-flashing/#flashing-newly-built-firmware","text":"First, make sure you have configured your computer as described in the Serial Port Configuration section of the user guide.","title":"Flashing Newly-Built Firmware"},{"location":"developer-guide/building-flashing/#f4","text":"Flash the firmware to the board by running make BOARD=REVO flash . If necessary, specify the serial port with make BOARD=REVO SERIAL_DEVICE=/dev/ttyACM0 flash .","title":"F4"},{"location":"developer-guide/building-flashing/#f1","text":"Flash the firmware to the board by running make BOARD=NAZE flash If necessary, specify the serial port with make BOARD=REVO SERIAL_DEVICE=/dev/ttyUSB0 flash .","title":"F1"},{"location":"developer-guide/code-architecture/","text":"Code Architecture The firmware is divided into two main components: the ROSflight library , and a collection of board implementations . This division is intended to allow the same core flight code to run on any processor or platform, either an embedded flight controller (such as the Naze32 or Revo) or a desktop environment for a software-in-the-loop (SIL) simulation. The interface between these two components is called the hardware abstraction layer (HAL). This architecture is illustrated in the following diagram: ROSflight Core Library The ROSflight library consists of all the code in the include and src directories of the firmware repository. This includes the code for what is termed the \"flight stack,\" which consists of the core components (such as the estimator, controller, state manager, etc.) required for flight. It also includes the interface definition for the hardware abstraction layer, which is defined by the abstract Board class in include/board.h . The communications link (MAVLink) is also abstracted, with the interface defined by the CommLink class in include/comm_link.h . External libraries are contained in the lib folder. Board Abstraction The hardware abstraction implementations are contained in the board directory, organized in subdirectories according to the hardware driver layer. The boards/airbourne directory uses drivers for boards using the STM32F4 processor, while the boards/breezy directory uses drivers for STM32F1 processors. Each board implementation is required to provide an implementation of the hardware abstraction layer interface, which is passed by reference to the flight stack. The Revo implementation in the boards/airbourne shows how this is done for an embedded flight controller. Examples of board implementations for SIL simulation are found in the rosflight_firmware and rosflight_sim ROS packages available here . The flight stack is encapsulated in the ROSflight class defined at include/rosflight.h . This class contains two public functions: init() and run() . Its constructor requires two arguments: an implementation of the Board interface, and an implementation of the CommLink interface. Each board implementation is required to: Provide its own main() function that instantiates an implementation of the Board interface, Instantiate a ROSflight object with that board interface as an argument, Call the init() method of that ROSflight object once, Then call the run() method in a loop. For example, here is the main function for the Naze32 board implementation ( boards/breezy/main.cpp ): #include breezy_board.h #include rosflight.h #include mavlink.h int main () { rosflight_firmware :: BreezyBoard board ; board . init_board (); rosflight_firmware :: Mavlink mavlink ( board ); rosflight_firmware :: ROSflight firmware ( board , mavlink ); firmware . init (); while ( true ) { firmware . run (); } return 0 ; } Comm Link Abstraction The purpose of the comm link abstraction layer is to allow communication protocols other than MAVLink to be used if desired. The comm link abstraction implementations are contained in the comms directory, organized in subdirectories by protocol. The implementations translate between the messages that the firmware expects to send and receive, and the messages defined by the communication protocol. Currently, only MAVLink is implemented. Flight Stack The flight stack is encapsulated by the ROSflight class defined in include/rosflight.h . It consists of a collection of modules . Each of these modules is implemented as a C++ class, and encapsulates a cohesive piece of the autopilot functionality. The following diagram illustrates these modules and the data flow between them. Rectangular blocks represent modules in the flight stack, and ellipses represent hardware functionality implemented in the board support layer: We'll describe each of these modules in the following sections: State Manager This module is in charge of keeping track of the internal state (armed status, error codes, failsafe, etc.) of the vehicle. While only the comm manager data flow is illustrated on the diagram, all other modules query the state manager to determine the status and act appropriately based on that status. The operation of the state manager is defined by the following finite state machine: Parameter Server This module handles all parameters for the flight stack. It supports the getting and setting of integer and floating-point parameters, and the saving of these parameters to non-volatile memory. Setting and getting of parameters from the companion computer is done through the serial communication interface. While no other data flow lines are shown on the diagram, all of the other modules interact with the parameter server. Comm Manager This module handles all serial communication between the flight controller and companion computer. This includes streaming data and receiving offboard control setpoints and other commands from the computer. This module primarily collects data from the sensors, estimator, state manager, and parameters modules, and sends offboard control setpoints to the command manager and parameter requests to the parameter server. The actual communication protocol used is abstracted by the interface in include/comm_link.h . A new protocol can be used by implementing a wrapper around the protocol that inherits from this interface. Currently, only MAVLink has been implmented. The implementation is found in comms/mavlink/mavlink.h and comms/mavlink/mavlink.cpp . Sensors This module is in charge of managing the various sensors (IMU, magnetometer, barometer, differential pressure sensor, sonar altimeter, etc.). Its responsibilities include updating sensor data at appropriate rates, and computing and applying calibration parameters. Estimator This module is responsible for estimating the attitude and attitude rates of the vehicle from the sensor data. RC The RC module is responsible for interpreting the RC signals coming from the transmitter via the receiver. This includes mapping channels to their appropriate functions and reversing directions if necessary. Command Manager The command manager combines inputs from the RC and comm manager modules to produce a control setpoint. Its main purpose is to handle the interaction between offboard commands and the RC safety pilot, as well as to enforce the failsafe command if the state manager reports failsafe mode. Controller The controller uses the inputs from the command manager and estimator to compute a control output. This control output is computed in a generic form ( x x , y y , and z z torques, and force F F ), and is later converted into actual motor commands by the mixer. Mixer The mixer takes the generic outputs computed by the controller and maps them to actual motor commands depending on the configuration of the vehicle.","title":"Code Architecture"},{"location":"developer-guide/code-architecture/#code-architecture","text":"The firmware is divided into two main components: the ROSflight library , and a collection of board implementations . This division is intended to allow the same core flight code to run on any processor or platform, either an embedded flight controller (such as the Naze32 or Revo) or a desktop environment for a software-in-the-loop (SIL) simulation. The interface between these two components is called the hardware abstraction layer (HAL). This architecture is illustrated in the following diagram:","title":"Code Architecture"},{"location":"developer-guide/code-architecture/#rosflight-core-library","text":"The ROSflight library consists of all the code in the include and src directories of the firmware repository. This includes the code for what is termed the \"flight stack,\" which consists of the core components (such as the estimator, controller, state manager, etc.) required for flight. It also includes the interface definition for the hardware abstraction layer, which is defined by the abstract Board class in include/board.h . The communications link (MAVLink) is also abstracted, with the interface defined by the CommLink class in include/comm_link.h . External libraries are contained in the lib folder.","title":"ROSflight Core Library"},{"location":"developer-guide/code-architecture/#board-abstraction","text":"The hardware abstraction implementations are contained in the board directory, organized in subdirectories according to the hardware driver layer. The boards/airbourne directory uses drivers for boards using the STM32F4 processor, while the boards/breezy directory uses drivers for STM32F1 processors. Each board implementation is required to provide an implementation of the hardware abstraction layer interface, which is passed by reference to the flight stack. The Revo implementation in the boards/airbourne shows how this is done for an embedded flight controller. Examples of board implementations for SIL simulation are found in the rosflight_firmware and rosflight_sim ROS packages available here . The flight stack is encapsulated in the ROSflight class defined at include/rosflight.h . This class contains two public functions: init() and run() . Its constructor requires two arguments: an implementation of the Board interface, and an implementation of the CommLink interface. Each board implementation is required to: Provide its own main() function that instantiates an implementation of the Board interface, Instantiate a ROSflight object with that board interface as an argument, Call the init() method of that ROSflight object once, Then call the run() method in a loop. For example, here is the main function for the Naze32 board implementation ( boards/breezy/main.cpp ): #include breezy_board.h #include rosflight.h #include mavlink.h int main () { rosflight_firmware :: BreezyBoard board ; board . init_board (); rosflight_firmware :: Mavlink mavlink ( board ); rosflight_firmware :: ROSflight firmware ( board , mavlink ); firmware . init (); while ( true ) { firmware . run (); } return 0 ; }","title":"Board Abstraction"},{"location":"developer-guide/code-architecture/#comm-link-abstraction","text":"The purpose of the comm link abstraction layer is to allow communication protocols other than MAVLink to be used if desired. The comm link abstraction implementations are contained in the comms directory, organized in subdirectories by protocol. The implementations translate between the messages that the firmware expects to send and receive, and the messages defined by the communication protocol. Currently, only MAVLink is implemented.","title":"Comm Link Abstraction"},{"location":"developer-guide/code-architecture/#flight-stack","text":"The flight stack is encapsulated by the ROSflight class defined in include/rosflight.h . It consists of a collection of modules . Each of these modules is implemented as a C++ class, and encapsulates a cohesive piece of the autopilot functionality. The following diagram illustrates these modules and the data flow between them. Rectangular blocks represent modules in the flight stack, and ellipses represent hardware functionality implemented in the board support layer: We'll describe each of these modules in the following sections:","title":"Flight Stack"},{"location":"developer-guide/code-architecture/#state-manager","text":"This module is in charge of keeping track of the internal state (armed status, error codes, failsafe, etc.) of the vehicle. While only the comm manager data flow is illustrated on the diagram, all other modules query the state manager to determine the status and act appropriately based on that status. The operation of the state manager is defined by the following finite state machine:","title":"State Manager"},{"location":"developer-guide/code-architecture/#parameter-server","text":"This module handles all parameters for the flight stack. It supports the getting and setting of integer and floating-point parameters, and the saving of these parameters to non-volatile memory. Setting and getting of parameters from the companion computer is done through the serial communication interface. While no other data flow lines are shown on the diagram, all of the other modules interact with the parameter server.","title":"Parameter Server"},{"location":"developer-guide/code-architecture/#comm-manager","text":"This module handles all serial communication between the flight controller and companion computer. This includes streaming data and receiving offboard control setpoints and other commands from the computer. This module primarily collects data from the sensors, estimator, state manager, and parameters modules, and sends offboard control setpoints to the command manager and parameter requests to the parameter server. The actual communication protocol used is abstracted by the interface in include/comm_link.h . A new protocol can be used by implementing a wrapper around the protocol that inherits from this interface. Currently, only MAVLink has been implmented. The implementation is found in comms/mavlink/mavlink.h and comms/mavlink/mavlink.cpp .","title":"Comm Manager"},{"location":"developer-guide/code-architecture/#sensors","text":"This module is in charge of managing the various sensors (IMU, magnetometer, barometer, differential pressure sensor, sonar altimeter, etc.). Its responsibilities include updating sensor data at appropriate rates, and computing and applying calibration parameters.","title":"Sensors"},{"location":"developer-guide/code-architecture/#estimator","text":"This module is responsible for estimating the attitude and attitude rates of the vehicle from the sensor data.","title":"Estimator"},{"location":"developer-guide/code-architecture/#rc","text":"The RC module is responsible for interpreting the RC signals coming from the transmitter via the receiver. This includes mapping channels to their appropriate functions and reversing directions if necessary.","title":"RC"},{"location":"developer-guide/code-architecture/#command-manager","text":"The command manager combines inputs from the RC and comm manager modules to produce a control setpoint. Its main purpose is to handle the interaction between offboard commands and the RC safety pilot, as well as to enforce the failsafe command if the state manager reports failsafe mode.","title":"Command Manager"},{"location":"developer-guide/code-architecture/#controller","text":"The controller uses the inputs from the command manager and estimator to compute a control output. This control output is computed in a generic form ( x x , y y , and z z torques, and force F F ), and is later converted into actual motor commands by the mixer.","title":"Controller"},{"location":"developer-guide/code-architecture/#mixer","text":"The mixer takes the generic outputs computed by the controller and maps them to actual motor commands depending on the configuration of the vehicle.","title":"Mixer"},{"location":"developer-guide/contribution-guidelines/","text":"Contributing to the Firmware Note These documents are designed to help developers get up and running on developing new features by explaining firmware internals. Development is currently supported only on Ubuntu Linux 16.04 and 18.04. Per our vision stated in the introduction , ROSflight is intended to be a streamlined, bare-bones autopilot. We welcome any bug fixes, cleanup, or other contributions which do not add complexity or detract from the readability and simplified nature of the firmware. We hope that the firmware is useful, but in an attempt to avoid \"feature creep,\" we will be very discriminatory in merging pull requests whose purpose is to simply add features. Forking the repository in order to add features is totally acceptable and encouraged, just stay in contact with us, and recognize us as the original authors of the autopilot (per the agreement in the BSD-3 license). In addition, we strive to maintain a very high standard of quality in terms of code style, variable naming, and the like. We will likely be nit-picky and perhaps a little harsh about this in pull requests. Please do not be offended. By maintaining a high standard, we hope that the code will continue to be useful, understandable, and cohesive in nature. Pull requests are also required to pass the automated unit tests. You can test your changes against these unit tests before pushing by executing the run_tests.sh script in the scripts directory of the firmware repo. Although we strive for complete in-code documentation, in practice this often gets left behind for the sake of rapid development. If you, as a potential developer, find some portion of documentation unsatisfactory, we welcome questions on the GitHub issues page or forum , and pull requests which improve documentation. Several new developers have started with first improving the documentation to get a handle on how things work. Communication There are two channels to communicate with the developer team. For bug reports, feature requests, and anything to do with code, please open an issue on the appropriate firmware or ROS stack GitHub issue page. For questions and other discussions, please use the forum .","title":"Contribution Guidelines"},{"location":"developer-guide/contribution-guidelines/#contributing-to-the-firmware","text":"Note These documents are designed to help developers get up and running on developing new features by explaining firmware internals. Development is currently supported only on Ubuntu Linux 16.04 and 18.04. Per our vision stated in the introduction , ROSflight is intended to be a streamlined, bare-bones autopilot. We welcome any bug fixes, cleanup, or other contributions which do not add complexity or detract from the readability and simplified nature of the firmware. We hope that the firmware is useful, but in an attempt to avoid \"feature creep,\" we will be very discriminatory in merging pull requests whose purpose is to simply add features. Forking the repository in order to add features is totally acceptable and encouraged, just stay in contact with us, and recognize us as the original authors of the autopilot (per the agreement in the BSD-3 license). In addition, we strive to maintain a very high standard of quality in terms of code style, variable naming, and the like. We will likely be nit-picky and perhaps a little harsh about this in pull requests. Please do not be offended. By maintaining a high standard, we hope that the code will continue to be useful, understandable, and cohesive in nature. Pull requests are also required to pass the automated unit tests. You can test your changes against these unit tests before pushing by executing the run_tests.sh script in the scripts directory of the firmware repo. Although we strive for complete in-code documentation, in practice this often gets left behind for the sake of rapid development. If you, as a potential developer, find some portion of documentation unsatisfactory, we welcome questions on the GitHub issues page or forum , and pull requests which improve documentation. Several new developers have started with first improving the documentation to get a handle on how things work.","title":"Contributing to the Firmware"},{"location":"developer-guide/contribution-guidelines/#communication","text":"There are two channels to communicate with the developer team. For bug reports, feature requests, and anything to do with code, please open an issue on the appropriate firmware or ROS stack GitHub issue page. For questions and other discussions, please use the forum .","title":"Communication"},{"location":"developer-guide/debugging/","text":"Using an In-Circuit Debugger Debugging a Naze32 is easiest with an ST-Link V2. You can find these on Amazon and other websites. The following guide will get you up and running with QtCreator or Visual Studio Code and the in-circuit debugger. Warning We have had reports of problems with cheap clones of ST-Links not connecting. Add User to Dialout Group Tip You can see which groups you are in by running groups $USER on the command line. First, make sure you are in the dialout group. If you are not in the dialout group, run: sudo usermod -aG dialout $USER Log out and back in for changes to take effect. Install IDE QtCreator For some reason, the QtCreator bundled with 16.04 is unstable. Use the most recent build of QtCreator which can be downloaded here . If you are on 18.04, you can install via apt. The following instructions are for installing Qt from the Qt provided installer: This downloads a .run file; just make it exectuable and run as sudo : cd ~/Downloads chmod +x qt-unified-linux-x64-3.0.4-online.run sudo ./qt-unified-linux-x64-3.0.4-online.run If you want the icon to appear in your unity menu, create the following file as ~/.local/share/applications/qtcreator.desktop (assuming that you installed qtcreator to the Qt folder in the installer) [Desktop Entry] Exec=bash -i -c /opt/Qt/Tools/QtCreator/bin/qtcreator.sh %F Icon=qtcreator Type=Application Terminal=false Name=Qt Creator GenericName=Integrated Development Environment MimeType=text/x-c++src;text/x-c++hdr;text/x-xsrc;application/x-designer;application/vnd.nokia.qt.qmakeprofile;application/vnd.nokia.xml.qt.resource; Categories=Qt;Development;IDE; InitialPreference=9 VSCode You can install Visual Studio Code by downloading the latest version from their website . The debugging tools provided by VSCode have been confirmed to work on both Mac and Linux. Install openocd For QtCreator Open OCD (On-Chip-Debugger) is the software that will control the debugger. We are going to install the version that is configured to work as a plugin for the eclipse IDE. To get this version, go to the releases page of the OpenOCD github page and download the latest .tgz file. You can use the following commands, substituting the version you downloaded for : cd ~/Downloads tar -xvf gnuarmeclipse-openocd- version -dev.tgz sudo mv openocd /opt/ Then, for convenience, I normally create a script to run openocd for me. Here is my start_openocd_f1 script: #!/bin/bash cd /opt/openocd/0.10.0-201701241841/bin # Use the correct version ./openocd -f interface/stlink-v2.cfg -f target/stm32f1x.cfg Here is my start_openocd_f4 script: #!/bin/bash cd /opt/openocd/0.10.0-5-20171110-1117/bin ./openocd -f interface/stlink-v2.cfg -f target/stm32f4x.cfg Note On more recent versions of openocd, interface/stlink-v2.cfg is deprecated. Use interface/stlink.cfg instead. I move these to the /usr/local/bin directory so I can call it from anywhere: chmod +x start_openocd_f1 chmod +x start_openocd_f4 mv start_openocd_f1 /usr/local/bin mv start_openocd_f4 /usr/local/bin For VSCode For VSCode, install the openocd version currently available through your package manager: Ubuntu: sudo apt install openocd Mac: brew install open-ocd The start_openocd_f4 script requires a few additional parameters to ensure proper connection to VSCode and GDB: #!/bin/bash cd /opt/openocd/0.10.0-11-20190118-1134/bin ./openocd -f interface/stlink.cfg -f target/stm32f4x.cfg -c gdb_port 50250 -c init -c reset init As shown above, this script can be added to your /usr/local/bin if you want to be able to call it from anywhere. Install ARM compiler and 32-bit Dependencies Follow the guide in Building and Flashing to install the compiler. QtCreator also needs 32-bit python bindings to run GDB (skip this if using VSCode) sudo dpkg --add-architecture i386 sudo apt update sudo apt install libpython2.7:i386 Configure QtCreator for ARM Development Open up the new QtCreator you just installed (make sure it's the new one, and not the version you get from apt ) Turn on the \"Bare Metal Plugin\" Help - About Plugins - Enable \"Bare Metal\" Restart QtCreator Now, we are going to configure a new \"Kit\" for ARM development. (This allows you to quickly switch back and forth between ARM and normal development.) Tell QtCreator where to find the compiler (GCC) Tools - Options - Build Run - Compilers - Add - GCC - C++. Name the new compiler, e.g. \"G++ ARM\" Point the compiler path to where you just installed your fresh GCC The path for G++ /opt/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-g++ Do the same for GCC (if you are going to be doing any C-only code) Tools - Options - Build Run - Compilers - Add - GCC - C. Name the compiler, e.g. \"GCC ARM\" Point the compiler path to where you just installed your fresh GCC The path for GCC is /opt/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-gcc Add the Debugger (GDB) Tools - Options - Build Run - Debuggers - Add - GDB. Name it something Point it to the new debugger you just installed The Path for /opt/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-gdb-py Configure the STLink-V2 with OpenOCD Go to the Bare Metal Plugin Tools - Options - Devices - Bare Metal - Add - OpenOCD Leave all options at default values and click Apply Tools - Options - Devices - Devices - Add - Bare Metal Device - Start Wizard Name: ST-Link V2 GDB Server Provider: OpenOCD Build the new Development Kit Tools - Options - Build Run - Kits - Add Name: ARM Device Type: Bare Metal Device Device: ST-Link V2 Compiler: GCC ARM/G++ ARM Debugger: ARM GDB Qt Version: None Configure VSCode for ARM Development Open the debugger launch.json file by navigating to the Debug pane (Ctrl + Shift + D) and clicking the gear at the top of the screen: Add a configuration entry to the launch.json file that looks something like this (be sure to substitute the correct folder name for your version of the gcc-arm compiler): { name : GDB-REVO , type : cppdbg , request : launch , MIMode : gdb , targetArchitecture : arm , miDebuggerPath : /opt/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-gdb , program : ${workspaceRoot}/boards/airbourne/build/rosflight_REVO_Debug.elf , externalConsole : false , cwd : ${workspaceRoot} , setupCommands : [ { text : file ${workspaceRoot}/boards/airbourne/build/rosflight_REVO_Debug.elf }, { text : set remotetimeout 30 }, { text : target remote localhost:50250 }, { text : monitor halt }, { text : monitor reset init }, { text : load }, { text : info target } ], } Note that you will need to change the program and first setupCommands.text entries if you want to run a different example or version of the firmware. With a board plugged in and openocd running, you should now be able to press Play on the debug screen and launch the firmware in debug mode! If you do not want to call make from the terminal for every change, you can also create a simple task in VSCode to do it for you. Open tasks.json from Command Pallette - Tasks: Configure Task { label : build , type : shell , command : make } Test the Debugger Here are the instructions for an F1 target. The instructions are very similar for an F4, just choose the correct .elf file. Turn on the Debugger Connect the debugger to your flight controller. Here is the pinout for the Flip32 and Flip32+: Plug in the debugger and start openocd (you will need sudo privileges): sudo start_openocd_f1 Build the Correct Example Code Import Existing Project Open the root of the firmware Do not add .creator files to the Git repository Configure the Build Environment Go to the \"Projects\" tab on the left hand side Switch to the ARM Kit we just created Build Settings: Change \"Build Directory\" to the firmware root Build Steps: make BOARD=NAZE DEBUG=GDB Run Settings: Change \"Run Configuration\" to hardware debugger Choose the .elf file in the boards/breezy/build directory (you'll need to build first) firmware/boards/breezy/build/rosflight.elf You're done! Just select the \"Debug\" tab and debug your project!","title":"Using a Debugger"},{"location":"developer-guide/debugging/#using-an-in-circuit-debugger","text":"Debugging a Naze32 is easiest with an ST-Link V2. You can find these on Amazon and other websites. The following guide will get you up and running with QtCreator or Visual Studio Code and the in-circuit debugger. Warning We have had reports of problems with cheap clones of ST-Links not connecting.","title":"Using an In-Circuit Debugger"},{"location":"developer-guide/debugging/#add-user-to-dialout-group","text":"Tip You can see which groups you are in by running groups $USER on the command line. First, make sure you are in the dialout group. If you are not in the dialout group, run: sudo usermod -aG dialout $USER Log out and back in for changes to take effect.","title":"Add User to Dialout Group"},{"location":"developer-guide/debugging/#install-ide","text":"","title":"Install IDE"},{"location":"developer-guide/debugging/#qtcreator","text":"For some reason, the QtCreator bundled with 16.04 is unstable. Use the most recent build of QtCreator which can be downloaded here . If you are on 18.04, you can install via apt. The following instructions are for installing Qt from the Qt provided installer: This downloads a .run file; just make it exectuable and run as sudo : cd ~/Downloads chmod +x qt-unified-linux-x64-3.0.4-online.run sudo ./qt-unified-linux-x64-3.0.4-online.run If you want the icon to appear in your unity menu, create the following file as ~/.local/share/applications/qtcreator.desktop (assuming that you installed qtcreator to the Qt folder in the installer) [Desktop Entry] Exec=bash -i -c /opt/Qt/Tools/QtCreator/bin/qtcreator.sh %F Icon=qtcreator Type=Application Terminal=false Name=Qt Creator GenericName=Integrated Development Environment MimeType=text/x-c++src;text/x-c++hdr;text/x-xsrc;application/x-designer;application/vnd.nokia.qt.qmakeprofile;application/vnd.nokia.xml.qt.resource; Categories=Qt;Development;IDE; InitialPreference=9","title":"QtCreator"},{"location":"developer-guide/debugging/#vscode","text":"You can install Visual Studio Code by downloading the latest version from their website . The debugging tools provided by VSCode have been confirmed to work on both Mac and Linux.","title":"VSCode"},{"location":"developer-guide/debugging/#install-openocd","text":"","title":"Install openocd"},{"location":"developer-guide/debugging/#for-qtcreator","text":"Open OCD (On-Chip-Debugger) is the software that will control the debugger. We are going to install the version that is configured to work as a plugin for the eclipse IDE. To get this version, go to the releases page of the OpenOCD github page and download the latest .tgz file. You can use the following commands, substituting the version you downloaded for : cd ~/Downloads tar -xvf gnuarmeclipse-openocd- version -dev.tgz sudo mv openocd /opt/ Then, for convenience, I normally create a script to run openocd for me. Here is my start_openocd_f1 script: #!/bin/bash cd /opt/openocd/0.10.0-201701241841/bin # Use the correct version ./openocd -f interface/stlink-v2.cfg -f target/stm32f1x.cfg Here is my start_openocd_f4 script: #!/bin/bash cd /opt/openocd/0.10.0-5-20171110-1117/bin ./openocd -f interface/stlink-v2.cfg -f target/stm32f4x.cfg Note On more recent versions of openocd, interface/stlink-v2.cfg is deprecated. Use interface/stlink.cfg instead. I move these to the /usr/local/bin directory so I can call it from anywhere: chmod +x start_openocd_f1 chmod +x start_openocd_f4 mv start_openocd_f1 /usr/local/bin mv start_openocd_f4 /usr/local/bin","title":"For QtCreator"},{"location":"developer-guide/debugging/#for-vscode","text":"For VSCode, install the openocd version currently available through your package manager: Ubuntu: sudo apt install openocd Mac: brew install open-ocd The start_openocd_f4 script requires a few additional parameters to ensure proper connection to VSCode and GDB: #!/bin/bash cd /opt/openocd/0.10.0-11-20190118-1134/bin ./openocd -f interface/stlink.cfg -f target/stm32f4x.cfg -c gdb_port 50250 -c init -c reset init As shown above, this script can be added to your /usr/local/bin if you want to be able to call it from anywhere.","title":"For VSCode"},{"location":"developer-guide/debugging/#install-arm-compiler-and-32-bit-dependencies","text":"Follow the guide in Building and Flashing to install the compiler. QtCreator also needs 32-bit python bindings to run GDB (skip this if using VSCode) sudo dpkg --add-architecture i386 sudo apt update sudo apt install libpython2.7:i386","title":"Install ARM compiler and 32-bit Dependencies"},{"location":"developer-guide/debugging/#configure-qtcreator-for-arm-development","text":"Open up the new QtCreator you just installed (make sure it's the new one, and not the version you get from apt )","title":"Configure QtCreator for ARM Development"},{"location":"developer-guide/debugging/#turn-on-the-bare-metal-plugin","text":"Help - About Plugins - Enable \"Bare Metal\" Restart QtCreator Now, we are going to configure a new \"Kit\" for ARM development. (This allows you to quickly switch back and forth between ARM and normal development.)","title":"Turn on the \"Bare Metal Plugin\""},{"location":"developer-guide/debugging/#tell-qtcreator-where-to-find-the-compiler-gcc","text":"Tools - Options - Build Run - Compilers - Add - GCC - C++. Name the new compiler, e.g. \"G++ ARM\" Point the compiler path to where you just installed your fresh GCC The path for G++ /opt/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-g++ Do the same for GCC (if you are going to be doing any C-only code) Tools - Options - Build Run - Compilers - Add - GCC - C. Name the compiler, e.g. \"GCC ARM\" Point the compiler path to where you just installed your fresh GCC The path for GCC is /opt/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-gcc","title":"Tell QtCreator where to find the compiler (GCC)"},{"location":"developer-guide/debugging/#add-the-debugger-gdb","text":"Tools - Options - Build Run - Debuggers - Add - GDB. Name it something Point it to the new debugger you just installed The Path for /opt/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-gdb-py","title":"Add the Debugger (GDB)"},{"location":"developer-guide/debugging/#configure-the-stlink-v2-with-openocd","text":"Go to the Bare Metal Plugin Tools - Options - Devices - Bare Metal - Add - OpenOCD Leave all options at default values and click Apply Tools - Options - Devices - Devices - Add - Bare Metal Device - Start Wizard Name: ST-Link V2 GDB Server Provider: OpenOCD","title":"Configure the STLink-V2 with OpenOCD"},{"location":"developer-guide/debugging/#build-the-new-development-kit","text":"Tools - Options - Build Run - Kits - Add Name: ARM Device Type: Bare Metal Device Device: ST-Link V2 Compiler: GCC ARM/G++ ARM Debugger: ARM GDB Qt Version: None","title":"Build the new Development Kit"},{"location":"developer-guide/debugging/#configure-vscode-for-arm-development","text":"Open the debugger launch.json file by navigating to the Debug pane (Ctrl + Shift + D) and clicking the gear at the top of the screen: Add a configuration entry to the launch.json file that looks something like this (be sure to substitute the correct folder name for your version of the gcc-arm compiler): { name : GDB-REVO , type : cppdbg , request : launch , MIMode : gdb , targetArchitecture : arm , miDebuggerPath : /opt/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-gdb , program : ${workspaceRoot}/boards/airbourne/build/rosflight_REVO_Debug.elf , externalConsole : false , cwd : ${workspaceRoot} , setupCommands : [ { text : file ${workspaceRoot}/boards/airbourne/build/rosflight_REVO_Debug.elf }, { text : set remotetimeout 30 }, { text : target remote localhost:50250 }, { text : monitor halt }, { text : monitor reset init }, { text : load }, { text : info target } ], } Note that you will need to change the program and first setupCommands.text entries if you want to run a different example or version of the firmware. With a board plugged in and openocd running, you should now be able to press Play on the debug screen and launch the firmware in debug mode! If you do not want to call make from the terminal for every change, you can also create a simple task in VSCode to do it for you. Open tasks.json from Command Pallette - Tasks: Configure Task { label : build , type : shell , command : make }","title":"Configure VSCode for ARM Development"},{"location":"developer-guide/debugging/#test-the-debugger","text":"Here are the instructions for an F1 target. The instructions are very similar for an F4, just choose the correct .elf file.","title":"Test the Debugger"},{"location":"developer-guide/debugging/#turn-on-the-debugger","text":"Connect the debugger to your flight controller. Here is the pinout for the Flip32 and Flip32+: Plug in the debugger and start openocd (you will need sudo privileges): sudo start_openocd_f1","title":"Turn on the Debugger"},{"location":"developer-guide/debugging/#build-the-correct-example-code","text":"Import Existing Project Open the root of the firmware Do not add .creator files to the Git repository","title":"Build the Correct Example Code"},{"location":"developer-guide/debugging/#configure-the-build-environment","text":"Go to the \"Projects\" tab on the left hand side Switch to the ARM Kit we just created Build Settings: Change \"Build Directory\" to the firmware root Build Steps: make BOARD=NAZE DEBUG=GDB Run Settings: Change \"Run Configuration\" to hardware debugger Choose the .elf file in the boards/breezy/build directory (you'll need to build first) firmware/boards/breezy/build/rosflight.elf You're done! Just select the \"Debug\" tab and debug your project!","title":"Configure the Build Environment"},{"location":"developer-guide/style-guide/","text":"Style Guide Any contributions to the firmware should adhere to the following style guidelines. White Space and Line Endings Please try not to commit anything that only changes white space or line endings. To check if that's going to happen, run git diff --check before you stage your files. Git will warn you about obnoxious changes. Please fix them. Code Style The following ROSflight code style is based on the ROS C++ style guide . ROSflight uses the C++11 standard. Indentation Indentation should be 2 spaces (no tabs). Case statements in switch blocks should not be indented, e.g. switch ( variable ) { case 1 : // do something break ; default : break ; } Braces Braces should be placed on the next line, e.g. if ( i 2 ) { // do stuff } else { // do something else } For a conditional with only one statement, the braces can be omitted but the statement should be indented: if ( i 2 ) x = 3 ; Spaces There should be a space between if , for , or while and the condition, e.g. while (true) , not while(true) . Naming Conventions Class names should be capitalized with no spaces (i.e. StateManager ). Member variables should contain a post-pended underscore (i.e. data_ ). Member functions should be all lower case with underscores (i.e. set_error() ). Integer types should be defined using the cstdint convention (i.e. uint8_t , int64_t , float , ...). Boolean values should be assigned true or false , not 0 or 1 . Function Arguments Primitive data types ( int , float , etc.) should always be passed by value. Other types (e.g. classes) should be passed by reference and should maintain proper const-correctness. Arguments that are modified by the function should be passed by pointer instead of reference, to make the fact that the argument will be changed clearer in the calling code. For example: void do_something ( float dt , const MyClass data , int * output ); This function would be called as float dt = 0.01f ; MyClass my_class ; int value ; do_something ( dt , my_class , value ); This makes it clear the value is modified by the function call. Classes All modules should be defined as a self-contained class. All member variables should be declared as \"private,\" named with a post-pended underscore, and accessed through inline accessor functions. All accessible data should be encapsulated in a struct. For example, here is a snippet from the Sensors module in the firmware: class Sensors { public : struct Data { vector_t accel = { 0 , 0 , 0 }; vector_t gyro = { 0 , 0 , 0 }; float imu_temperature = 0 ; uint64_t imu_time = 0 ; float diff_pressure_velocity = 0 ; float diff_pressure = 0 ; float diff_pressure_temp = 0 ; bool diff_pressure_valid = false ; float baro_altitude = 0 ; float baro_pressure = 0 ; float baro_temperature = 0 ; bool baro_valid = false ; float sonar_range = 0 ; bool sonar_range_valid = false ; vector_t mag = { 0 , 0 , 0 }; bool baro_present = false ; bool mag_present = false ; bool sonar_present = false ; bool diff_pressure_present = false ; }; Sensors ( ROSflight rosflight ); inline const Data data () const { return data_ ; } private : Data data_ ; } Note that data_ is a private member variable, but the Data struct is declared publicly and data_ is accessed through an inline const accessor to prevent another module from changing data_ . Enums Enums should be declared using the following style: enum ArmedState { ARMED_STATE_INIT , ARMED_STATE_DISARMED , ARMED_STATE_ARMED }; The name of the enum should be in CamelCase, and the names of its members should be ALL_CAPS. Where practical, have the members of the enum begin with the name of the enum. Structs Structs should be declared using the following style: struct SomeValue { int v1 ; int v2 ; }; Struct type names should be in CamelCase. Globals The use of global variables should be limited to when absolutely necessary (such as linking to interrupt routines or hardware peripherals). This should only occur in board support layers and not in the core ROSflight libary code. Include Order Include files at the top of your file in the following order: Standard library (e.g. cstdint ) Files from external libraries included in the project (e.g. breezystm32/breezystm32.h , mavlink/v1.0/common/mavlink.h ) Other header files from this project (e.g. \"rosflight.h\" ) The header file for this specific source file Group the includes according to the above list with an empty line between each group. (For external libraries, you may subdivide group 2 into a group for each library.) The first two groups should use angle brackets ( ), and the last two groups should use quotation marks ( \"\" ). Files from external libraries should be namespaced by the library name (e.g. breezystm32/breezystm32.h , not breezystm32.h ). Alphabetize the files within each group. Do not change the include order to fix build errors; if you have to do that it means you are not including a file somewhere that you should. Please fix it by including all the right files. Include C standard library headers using the C++ style ( #include cmath ) instead of the C style ( #include math.h ). For example, in sensors.c I might have: #include cstdbool #include cstdint #include breezystm32/breezystm32.h #include breezystm32/drv_mpu6050.h #include param.h #include sensors.h Namespacing All modules in the firmware should be encapsulated in the rosflight_firmware namespace. This prevents name-clashing in SIL compilation.","title":"Style Guide"},{"location":"developer-guide/style-guide/#style-guide","text":"Any contributions to the firmware should adhere to the following style guidelines.","title":"Style Guide"},{"location":"developer-guide/style-guide/#white-space-and-line-endings","text":"Please try not to commit anything that only changes white space or line endings. To check if that's going to happen, run git diff --check before you stage your files. Git will warn you about obnoxious changes. Please fix them.","title":"White Space and Line Endings"},{"location":"developer-guide/style-guide/#code-style","text":"The following ROSflight code style is based on the ROS C++ style guide . ROSflight uses the C++11 standard.","title":"Code Style"},{"location":"developer-guide/style-guide/#indentation","text":"Indentation should be 2 spaces (no tabs). Case statements in switch blocks should not be indented, e.g. switch ( variable ) { case 1 : // do something break ; default : break ; }","title":"Indentation"},{"location":"developer-guide/style-guide/#braces","text":"Braces should be placed on the next line, e.g. if ( i 2 ) { // do stuff } else { // do something else } For a conditional with only one statement, the braces can be omitted but the statement should be indented: if ( i 2 ) x = 3 ;","title":"Braces"},{"location":"developer-guide/style-guide/#spaces","text":"There should be a space between if , for , or while and the condition, e.g. while (true) , not while(true) .","title":"Spaces"},{"location":"developer-guide/style-guide/#naming-conventions","text":"Class names should be capitalized with no spaces (i.e. StateManager ). Member variables should contain a post-pended underscore (i.e. data_ ). Member functions should be all lower case with underscores (i.e. set_error() ). Integer types should be defined using the cstdint convention (i.e. uint8_t , int64_t , float , ...). Boolean values should be assigned true or false , not 0 or 1 .","title":"Naming Conventions"},{"location":"developer-guide/style-guide/#function-arguments","text":"Primitive data types ( int , float , etc.) should always be passed by value. Other types (e.g. classes) should be passed by reference and should maintain proper const-correctness. Arguments that are modified by the function should be passed by pointer instead of reference, to make the fact that the argument will be changed clearer in the calling code. For example: void do_something ( float dt , const MyClass data , int * output ); This function would be called as float dt = 0.01f ; MyClass my_class ; int value ; do_something ( dt , my_class , value ); This makes it clear the value is modified by the function call.","title":"Function Arguments"},{"location":"developer-guide/style-guide/#classes","text":"All modules should be defined as a self-contained class. All member variables should be declared as \"private,\" named with a post-pended underscore, and accessed through inline accessor functions. All accessible data should be encapsulated in a struct. For example, here is a snippet from the Sensors module in the firmware: class Sensors { public : struct Data { vector_t accel = { 0 , 0 , 0 }; vector_t gyro = { 0 , 0 , 0 }; float imu_temperature = 0 ; uint64_t imu_time = 0 ; float diff_pressure_velocity = 0 ; float diff_pressure = 0 ; float diff_pressure_temp = 0 ; bool diff_pressure_valid = false ; float baro_altitude = 0 ; float baro_pressure = 0 ; float baro_temperature = 0 ; bool baro_valid = false ; float sonar_range = 0 ; bool sonar_range_valid = false ; vector_t mag = { 0 , 0 , 0 }; bool baro_present = false ; bool mag_present = false ; bool sonar_present = false ; bool diff_pressure_present = false ; }; Sensors ( ROSflight rosflight ); inline const Data data () const { return data_ ; } private : Data data_ ; } Note that data_ is a private member variable, but the Data struct is declared publicly and data_ is accessed through an inline const accessor to prevent another module from changing data_ .","title":"Classes"},{"location":"developer-guide/style-guide/#enums","text":"Enums should be declared using the following style: enum ArmedState { ARMED_STATE_INIT , ARMED_STATE_DISARMED , ARMED_STATE_ARMED }; The name of the enum should be in CamelCase, and the names of its members should be ALL_CAPS. Where practical, have the members of the enum begin with the name of the enum.","title":"Enums"},{"location":"developer-guide/style-guide/#structs","text":"Structs should be declared using the following style: struct SomeValue { int v1 ; int v2 ; }; Struct type names should be in CamelCase.","title":"Structs"},{"location":"developer-guide/style-guide/#globals","text":"The use of global variables should be limited to when absolutely necessary (such as linking to interrupt routines or hardware peripherals). This should only occur in board support layers and not in the core ROSflight libary code.","title":"Globals"},{"location":"developer-guide/style-guide/#include-order","text":"Include files at the top of your file in the following order: Standard library (e.g. cstdint ) Files from external libraries included in the project (e.g. breezystm32/breezystm32.h , mavlink/v1.0/common/mavlink.h ) Other header files from this project (e.g. \"rosflight.h\" ) The header file for this specific source file Group the includes according to the above list with an empty line between each group. (For external libraries, you may subdivide group 2 into a group for each library.) The first two groups should use angle brackets ( ), and the last two groups should use quotation marks ( \"\" ). Files from external libraries should be namespaced by the library name (e.g. breezystm32/breezystm32.h , not breezystm32.h ). Alphabetize the files within each group. Do not change the include order to fix build errors; if you have to do that it means you are not including a file somewhere that you should. Please fix it by including all the right files. Include C standard library headers using the C++ style ( #include cmath ) instead of the C style ( #include math.h ). For example, in sensors.c I might have: #include cstdbool #include cstdint #include breezystm32/breezystm32.h #include breezystm32/drv_mpu6050.h #include param.h #include sensors.h","title":"Include Order"},{"location":"developer-guide/style-guide/#namespacing","text":"All modules in the firmware should be encapsulated in the rosflight_firmware namespace. This prevents name-clashing in SIL compilation.","title":"Namespacing"},{"location":"developer-guide/unit-tests/","text":"Building and Running Unit Tests Contributions will need to pass our continuous integration unit tests before merging. To test your contributions against these tests, you'll first need to install Eigen and gtest: sudo apt install libgtest-dev libeigen3-dev cmake Compile gtest You just downloaded a bunch of source files, which you now have to go build sudo apt install cmake cd /usr/src/gtest sudo cmake CMakeLists.txt sudo make Copy the archive files you just built to the /usr/lib directory so CMake can find them later: sudo cp *.a /usr/lib Run the Test Script The simplest way to run the unit tests is to use the testing script. This script first checks that the firmware compiles, then runs the unit tests. This is the same script used on the continuous integration server, so this is a great way to check that your code will pass the tests before opening a pull request. Run the test script with cd firmware_directory ./scripts/run_tests.sh Manually Build and Run the Unit Tests If you want to manually build and run the unit tests, first build them with the following commands: cd firmware_directory /test mkdir build cd build cmake .. make Then run them with: ./unit_tests","title":"Unit Tests"},{"location":"developer-guide/unit-tests/#building-and-running-unit-tests","text":"Contributions will need to pass our continuous integration unit tests before merging. To test your contributions against these tests, you'll first need to install Eigen and gtest: sudo apt install libgtest-dev libeigen3-dev cmake","title":"Building and Running Unit Tests"},{"location":"developer-guide/unit-tests/#compile-gtest","text":"You just downloaded a bunch of source files, which you now have to go build sudo apt install cmake cd /usr/src/gtest sudo cmake CMakeLists.txt sudo make Copy the archive files you just built to the /usr/lib directory so CMake can find them later: sudo cp *.a /usr/lib","title":"Compile gtest"},{"location":"developer-guide/unit-tests/#run-the-test-script","text":"The simplest way to run the unit tests is to use the testing script. This script first checks that the firmware compiles, then runs the unit tests. This is the same script used on the continuous integration server, so this is a great way to check that your code will pass the tests before opening a pull request. Run the test script with cd firmware_directory ./scripts/run_tests.sh","title":"Run the Test Script"},{"location":"developer-guide/unit-tests/#manually-build-and-run-the-unit-tests","text":"If you want to manually build and run the unit tests, first build them with the following commands: cd firmware_directory /test mkdir build cd build cmake .. make Then run them with: ./unit_tests","title":"Manually Build and Run the Unit Tests"},{"location":"developer-guide/writing-documentation/","text":"Writing Documentation All documentation for the entire ROSflight stack (both firmware and ROS code) belongs in this \"MkDocs\" webpage. This guide explains how to build the documentation on your own local computer so you can view changes as you write and contribute to the documentation. Install mkdocs and LaTeX Support This is easy: pip install --user mkdocs mkdocs-material pygments pymdown-extensions (You don't have use to the global pip if you have python environments working, but for beginners, this is the simplest way to do it.) Run the mkdocs Server Just type mkdocs serve in the root directory of the firmware repository. It should report to you something like: [ I 170728 07 :49:47 server:271 ] Serving on http://127.0.0.1:8000 [ I 170728 07 :49:47 handlers:58 ] Start watching changes This means that mkdocs is hosting a webpage for you on http://127.0.0.1:8000. Navigate to that page in your web browser. Now, as you make changes to the documentation, you should be able to see it on your browser. Just hit reload from time to time to see your changes. Adding Pages To add a new page to the documentation, just take a look at the mkdocs.yml file in the root of the firmware directory. You should be able to figure it out from there. Adding LaTeX The syntax for adding LaTeX math inline is \\( x \\) , which renders as x x . For adding a block, it's $$ E = mc^ 2 $$ which renders as $$ E = mc^2 $$","title":"Writing Documentation"},{"location":"developer-guide/writing-documentation/#writing-documentation","text":"All documentation for the entire ROSflight stack (both firmware and ROS code) belongs in this \"MkDocs\" webpage. This guide explains how to build the documentation on your own local computer so you can view changes as you write and contribute to the documentation.","title":"Writing Documentation"},{"location":"developer-guide/writing-documentation/#install-mkdocs-and-latex-support","text":"This is easy: pip install --user mkdocs mkdocs-material pygments pymdown-extensions (You don't have use to the global pip if you have python environments working, but for beginners, this is the simplest way to do it.)","title":"Install mkdocs and LaTeX Support"},{"location":"developer-guide/writing-documentation/#run-the-mkdocs-server","text":"Just type mkdocs serve in the root directory of the firmware repository. It should report to you something like: [ I 170728 07 :49:47 server:271 ] Serving on http://127.0.0.1:8000 [ I 170728 07 :49:47 handlers:58 ] Start watching changes This means that mkdocs is hosting a webpage for you on http://127.0.0.1:8000. Navigate to that page in your web browser. Now, as you make changes to the documentation, you should be able to see it on your browser. Just hit reload from time to time to see your changes.","title":"Run the mkdocs Server"},{"location":"developer-guide/writing-documentation/#adding-pages","text":"To add a new page to the documentation, just take a look at the mkdocs.yml file in the root of the firmware directory. You should be able to figure it out from there.","title":"Adding Pages"},{"location":"developer-guide/writing-documentation/#adding-latex","text":"The syntax for adding LaTeX math inline is \\( x \\) , which renders as x x . For adding a block, it's $$ E = mc^ 2 $$ which renders as $$ E = mc^2 $$","title":"Adding LaTeX"},{"location":"user-guide/autonomous-flight/","text":"Autonomous Flight One of the core functionalities of the ROSflight autopilot is to allow the companion computer to send control setpoints to the embedded flight controller. These setpoints would typically be computed by a controller running as a ROS node, normally on the companion computer. Provide Control from a Companion Computer Control setpoints are sent to the flight controller by publishing to the /command topic that is advertised by the rosflight_io node. This topic accepts messages of type rosflight_msgs/Command , which have the following structure: std_msgs/Header header uint8 mode uint8 ignore float32 x float32 y float32 z float32 F The header field is a standard ROS message header. The x , y , z , and F fields are the control setpoint values, which are interpreted according to the mode and ignore fields. The following table describes the different values the mode field can take, as well as how the setpoint values are interpreted for each of these modes: Value Enum x y z F 0 MODE_PASS_THROUGH aileron deflection (-1 to 1) elevator deflection (-1 to 1) rudder deflection (-1 to 1) throttle (0 to 1) 1 MODE_ROLLRATE_PITCHRATE_YAWRATE_THROTTLE roll rate (rad/s) pitch rate (rad/s) yaw rate (rad/s) throttle (0 to 1) 2 MODE_ROLL_PITCH_YAWRATE_THROTTLE roll angle (rad) pitch angle (rad) yaw rate (rad/s) throttle (0 to 1) The MODE_PASS_THROUGH mode is used for fixed-wing vehicles to directly specify the control surface deflections and throttle, while the MODE_ROLLRATE_PITCHRATE_YAWRATE_THROTTLE and MODE_ROLL_PITCH_YAWRATE_THROTTLE modes are used for multirotor vehicles to specify the attitude rates or angles, respectively. The ignore field is used if you want to specify control setpoints for some, but not all, of the axes. For example, I may want to specify throttle setpoints to perform altitude hold, while still letting the RC pilot specify the attitude setpoints. The ignore field is a bitmask that can be populated by combining the following values: Value Enum Result 0 IGNORE_NONE Ignore none of the fields (default) 1 IGNORE_X Ignore the x field 2 IGNORE_Y Ignore the y field 4 IGNORE_Z Ignore the z field 8 IGNORE_F Ignore the F field For the previous example, I would set the ignore field to a value of ignore = IGNORE_X | IGNORE_Y | IGNORE_Z The best practice is to use enum names rather than the actual numeric values for the mode and ignore fields. For example, to specify a multirotor attitude angle command in C++ I might have: #include ros/ros.h #include rosflight_msgs/Command.h rosflight_msgs :: Command msg ; msg . header . stamp = ros :: Time :: now (); msg . mode = rosflight_msgs :: Command :: MODE_ROLL_PITCH_YAWRATE_THROTTLE ; msg . ignore = rosflight_msgs :: Command :: IGNORE_NONE ; msg . x = 0.0 ; msg . y = 0.0 ; msg . z = 0.0 ; msg . F = 0.6 ; In Python I might have: import rospy from rosflight_msgs.msg import Command msg = Command () msg . header . stamp = rospy . Time . now () msg . mode = Command . MODE_ROLL_PITCH_YAWRATE_THROTTLE msg . ignore = Command . IGNORE_NONE msg . x = 0.0 msg . y = 0.0 msg . z = 0.0 msg . F = 0.6 I would then publish this message to the /command topic to forward it to the embedded flight controller. Note If the flight controller does not receive a new command for a defined period of time, it will ignore the old commands and revert to RC control. The length of this timeout period is set by the OFFBOARD_TIMEOUT parameter. Fly Waypoints with ROSplane or ROScopter Waypoint following is not supported natively by the ROSflight stack. However, the ROSplane and ROScopter projects are good, example implementations of how to achieve this using ROSflight. They also provide good examples of how you might go about integrating your own guidance or control algorithms with the ROSflight stack.","title":"Autonomous Flight"},{"location":"user-guide/autonomous-flight/#autonomous-flight","text":"One of the core functionalities of the ROSflight autopilot is to allow the companion computer to send control setpoints to the embedded flight controller. These setpoints would typically be computed by a controller running as a ROS node, normally on the companion computer.","title":"Autonomous Flight"},{"location":"user-guide/autonomous-flight/#provide-control-from-a-companion-computer","text":"Control setpoints are sent to the flight controller by publishing to the /command topic that is advertised by the rosflight_io node. This topic accepts messages of type rosflight_msgs/Command , which have the following structure: std_msgs/Header header uint8 mode uint8 ignore float32 x float32 y float32 z float32 F The header field is a standard ROS message header. The x , y , z , and F fields are the control setpoint values, which are interpreted according to the mode and ignore fields. The following table describes the different values the mode field can take, as well as how the setpoint values are interpreted for each of these modes: Value Enum x y z F 0 MODE_PASS_THROUGH aileron deflection (-1 to 1) elevator deflection (-1 to 1) rudder deflection (-1 to 1) throttle (0 to 1) 1 MODE_ROLLRATE_PITCHRATE_YAWRATE_THROTTLE roll rate (rad/s) pitch rate (rad/s) yaw rate (rad/s) throttle (0 to 1) 2 MODE_ROLL_PITCH_YAWRATE_THROTTLE roll angle (rad) pitch angle (rad) yaw rate (rad/s) throttle (0 to 1) The MODE_PASS_THROUGH mode is used for fixed-wing vehicles to directly specify the control surface deflections and throttle, while the MODE_ROLLRATE_PITCHRATE_YAWRATE_THROTTLE and MODE_ROLL_PITCH_YAWRATE_THROTTLE modes are used for multirotor vehicles to specify the attitude rates or angles, respectively. The ignore field is used if you want to specify control setpoints for some, but not all, of the axes. For example, I may want to specify throttle setpoints to perform altitude hold, while still letting the RC pilot specify the attitude setpoints. The ignore field is a bitmask that can be populated by combining the following values: Value Enum Result 0 IGNORE_NONE Ignore none of the fields (default) 1 IGNORE_X Ignore the x field 2 IGNORE_Y Ignore the y field 4 IGNORE_Z Ignore the z field 8 IGNORE_F Ignore the F field For the previous example, I would set the ignore field to a value of ignore = IGNORE_X | IGNORE_Y | IGNORE_Z The best practice is to use enum names rather than the actual numeric values for the mode and ignore fields. For example, to specify a multirotor attitude angle command in C++ I might have: #include ros/ros.h #include rosflight_msgs/Command.h rosflight_msgs :: Command msg ; msg . header . stamp = ros :: Time :: now (); msg . mode = rosflight_msgs :: Command :: MODE_ROLL_PITCH_YAWRATE_THROTTLE ; msg . ignore = rosflight_msgs :: Command :: IGNORE_NONE ; msg . x = 0.0 ; msg . y = 0.0 ; msg . z = 0.0 ; msg . F = 0.6 ; In Python I might have: import rospy from rosflight_msgs.msg import Command msg = Command () msg . header . stamp = rospy . Time . now () msg . mode = Command . MODE_ROLL_PITCH_YAWRATE_THROTTLE msg . ignore = Command . IGNORE_NONE msg . x = 0.0 msg . y = 0.0 msg . z = 0.0 msg . F = 0.6 I would then publish this message to the /command topic to forward it to the embedded flight controller. Note If the flight controller does not receive a new command for a defined period of time, it will ignore the old commands and revert to RC control. The length of this timeout period is set by the OFFBOARD_TIMEOUT parameter.","title":"Provide Control from a Companion Computer"},{"location":"user-guide/autonomous-flight/#fly-waypoints-with-rosplane-or-roscopter","text":"Waypoint following is not supported natively by the ROSflight stack. However, the ROSplane and ROScopter projects are good, example implementations of how to achieve this using ROSflight. They also provide good examples of how you might go about integrating your own guidance or control algorithms with the ROSflight stack.","title":"Fly Waypoints with ROSplane or ROScopter"},{"location":"user-guide/flight-controller-setup/","text":"Flight Controller Setup Note This page contains instructions for flashing pre-built firmware binaries. For instructions on building and flashing from source, see Building and Flashing in the Developer Guide. Compatible Hardware Warning Deprecation Notice: As of June 2019, plans are to deprecate support for the F1 in the near future. If you need to use an F1, you will need to retrieve an older version of the code that supports the F1. However, if there are issues, we will not be able to help you fix them. As of January 2018, ROSflight is only supported on flight controllers with STM32F103 and STM32F405 processors, specifically, the Revo, Naze32, and Flip32. Both the 6-DOF and 10-DOF versions of each board are fully supported. We have had the most success with Revo boards purchased from HobbyKing . We have had weird issues with knock-off boards from Chinese vendors. An acro version (IMU-Only) can be found at readytoflyquads . Serial Port Configuration Tip You can see which groups you are a member of by running groups $USER on the command line. The following bullet point is necessary: Be sure your user is in the dialout and plugdev groups so you have access to the serial ports. You will need to log out and back in for these changes to take effect. sudo usermod -aG dialout,plugdev $USER If you experience issues, you may need one or both of the next two bullet points: Temporarily stop the modem-manager (Sometimes, Linux thinks the device is a modem -- this command will be effective until next boot, or until you run the command again with start in place of stop ) sudo systemctl stop ModemManager.service Add the custom udev rule so Linux handles the flight controller properly (copy the following as /etc/udev/rules.d/45-stm32dfu.rules ) # DFU (Internal bootloader for STM32 MCUs) SUBSYSTEM == usb , ATTRS { idVendor }== 0483 , ATTRS { idProduct }== df11 , MODE = 0664 , GROUP = plugdev Tip You can permanently disable the ModemManager if you do not need it, then you won't have to disable it every time you reboot: sudo systemctl disable ModemManager.service Replace disable with enable to revert (i.e. if you find some other program you use needs access to it). Or you can uninstall it entirely from your system: sudo apt purge modemmanager Flashing Firmware using the Cleanflight Configurator Download the latest version of ROSflight for your board here . Install the Cleanflight configurator - It is an extension to Google Chrome - link Load the firmware, and flash using cleanflight configurator Open the configurator Open firmware flasher Connect your flight controller Make sure that you have selected the right port (or DFU in the case of F4-based boards) Select \"Load Firmware (Local)\" Select your *.hex file you downloaded earlier. Short the boot pins on your flight controller, unplug it, and and plug back in. If you scroll to the bottom of the screen, you will see the green bar indicate progress as the hex is flashed to the flight controller. You should then see something like the following: You're done! Great job. Flashing Firmware from the Command Line F4 Boards You can use dfu-util to flash the firmware. This is helpful if you need (or prefer) a command-line interface. Install the dfu-util utility sudo apt install dfu-util Download the latest rosflight-F4.bin file, found here Put the board in bootloader mode (short the boot pins while restarting the board by cycling power) Tip dfu-util auto-detects F4-based boards. Try dfu-util -l to make sure your board is in bootloader mode Flash the firmware to the device dfu-util -a 0 -s 0x08000000 -D rosflight-F4.bin F1 Boards You can use stm32flash to flash the firmware to F1-based boards. Install the stm32flash utility sudo apt install stm32flash Download the latest rosflight.hex file, found here , to the current directory Put the board in bootloader mode (short boot pins while restarting the Naze by cycling power) Flash the firmware to the proper device (replace /dev/ttyUSB0 ) stm32flash -w rosflight.hex -v -g 0x0 -b 921600 /dev/ttyUSB0","title":"Flight Controller Setup"},{"location":"user-guide/flight-controller-setup/#flight-controller-setup","text":"Note This page contains instructions for flashing pre-built firmware binaries. For instructions on building and flashing from source, see Building and Flashing in the Developer Guide.","title":"Flight Controller Setup"},{"location":"user-guide/flight-controller-setup/#compatible-hardware","text":"Warning Deprecation Notice: As of June 2019, plans are to deprecate support for the F1 in the near future. If you need to use an F1, you will need to retrieve an older version of the code that supports the F1. However, if there are issues, we will not be able to help you fix them. As of January 2018, ROSflight is only supported on flight controllers with STM32F103 and STM32F405 processors, specifically, the Revo, Naze32, and Flip32. Both the 6-DOF and 10-DOF versions of each board are fully supported. We have had the most success with Revo boards purchased from HobbyKing . We have had weird issues with knock-off boards from Chinese vendors. An acro version (IMU-Only) can be found at readytoflyquads .","title":"Compatible Hardware"},{"location":"user-guide/flight-controller-setup/#serial-port-configuration","text":"Tip You can see which groups you are a member of by running groups $USER on the command line. The following bullet point is necessary: Be sure your user is in the dialout and plugdev groups so you have access to the serial ports. You will need to log out and back in for these changes to take effect. sudo usermod -aG dialout,plugdev $USER If you experience issues, you may need one or both of the next two bullet points: Temporarily stop the modem-manager (Sometimes, Linux thinks the device is a modem -- this command will be effective until next boot, or until you run the command again with start in place of stop ) sudo systemctl stop ModemManager.service Add the custom udev rule so Linux handles the flight controller properly (copy the following as /etc/udev/rules.d/45-stm32dfu.rules ) # DFU (Internal bootloader for STM32 MCUs) SUBSYSTEM == usb , ATTRS { idVendor }== 0483 , ATTRS { idProduct }== df11 , MODE = 0664 , GROUP = plugdev Tip You can permanently disable the ModemManager if you do not need it, then you won't have to disable it every time you reboot: sudo systemctl disable ModemManager.service Replace disable with enable to revert (i.e. if you find some other program you use needs access to it). Or you can uninstall it entirely from your system: sudo apt purge modemmanager","title":"Serial Port Configuration"},{"location":"user-guide/flight-controller-setup/#flashing-firmware-using-the-cleanflight-configurator","text":"Download the latest version of ROSflight for your board here . Install the Cleanflight configurator - It is an extension to Google Chrome - link Load the firmware, and flash using cleanflight configurator Open the configurator Open firmware flasher Connect your flight controller Make sure that you have selected the right port (or DFU in the case of F4-based boards) Select \"Load Firmware (Local)\" Select your *.hex file you downloaded earlier. Short the boot pins on your flight controller, unplug it, and and plug back in. If you scroll to the bottom of the screen, you will see the green bar indicate progress as the hex is flashed to the flight controller. You should then see something like the following: You're done! Great job.","title":"Flashing Firmware using the Cleanflight Configurator"},{"location":"user-guide/flight-controller-setup/#flashing-firmware-from-the-command-line","text":"","title":"Flashing Firmware from the Command Line"},{"location":"user-guide/flight-controller-setup/#f4-boards","text":"You can use dfu-util to flash the firmware. This is helpful if you need (or prefer) a command-line interface. Install the dfu-util utility sudo apt install dfu-util Download the latest rosflight-F4.bin file, found here Put the board in bootloader mode (short the boot pins while restarting the board by cycling power) Tip dfu-util auto-detects F4-based boards. Try dfu-util -l to make sure your board is in bootloader mode Flash the firmware to the device dfu-util -a 0 -s 0x08000000 -D rosflight-F4.bin","title":"F4 Boards"},{"location":"user-guide/flight-controller-setup/#f1-boards","text":"You can use stm32flash to flash the firmware to F1-based boards. Install the stm32flash utility sudo apt install stm32flash Download the latest rosflight.hex file, found here , to the current directory Put the board in bootloader mode (short boot pins while restarting the Naze by cycling power) Flash the firmware to the proper device (replace /dev/ttyUSB0 ) stm32flash -w rosflight.hex -v -g 0x0 -b 921600 /dev/ttyUSB0","title":"F1 Boards"},{"location":"user-guide/gazebo_simulation/","text":"Running Simulations in Gazebo Rosflight comes with a useful tool allowing it to perform software-in-the-loop (SIL) simulations of the ROSflight firmware in gazebo. Architecture of the SIL Simulation To best mimic the hardware experience of ROSflight, the SIL plugin for Gazebo actually implements the firmware source code as a library. We just implemented a different \"board layer\" which uses gazebo instead of hardware calls for things like imu_read() and pwm_write() . Instead of a serial link over USB to the flight controller, we use a UDP connection bouncing off of localhost to communicate between rosflight_io and the firmware. This means the interface to the SIL plugin is identical to that of hardware. rosflight_io is the main gateway to the firmware in simulation, just as it is in hardware. The following table summarizes the correlation between connections in hardware and simulation: Connection Type Hardware Simulation Serial communications to rosflight_io USB / UART UDP RC PPM Receiver ROS RC topic ( rosflight_msgs/RCRaw ) Motors PWM Gazebo Plugin Sensors SPI/I2C Gazebo Plugin Quick-Start Guide to SIL Simulation create a catkin workspace clone the rosflight metapackage repository from github into your workspace clone submodules of the rosflight metapackage: git submodule update --init --recursive clone the rosflight_joy metapackage repository from github into your workspace install pygame: pip install --user pygame Perform a catkin_make roslaunch rosflight_sim multirotor.launch - This will open up a gazebo simulation, and you should have the following rqt_graph At this point, you can't actually do anything because there is no RC connection and no rosflight_io to talk to the firmware. Let's start by running a rosflight_io node. In a separate terminal, run rosrun rosflight rosflight_io _udp:=true . The udp parameter tells rosflight_io to simulate a serial connection over UDP rather than using the USB connection to hardware Your rqt_graph should look something like the following image. This looks funny because ROS doesn't actually know that there is a UDP connection between rosflight_io and gazebo. There is one, though, and you can test it by echoing any of the topics published by rosflight_io . Spin up a simulated RC connection. The easiest way to do this is with the helper package rosflight_joy . Connect a joystick to the computer (or Taranis transmitter) and run rosrun rosflight_joy rc_joy RC:=/multirotor/RC . This simulates the RC connection in hardware. If everything is mapped correctly, you should now be able to arm, disarm and fly the aircraft in simulation! Note It is much easier to fly with a real transmitter than with an Xbox-type controller. FrSky Taranis and RealFlight transmitters and interlinks are also supported. Non-Xbox joysticks may have incorrect mappings. If your joystick does not work, and you write your own mapping, please contribute back your new joystick mapping! Remember, the SIL tries its best to replicate hardware. That means you have to calibrate and set parameters in the same way you do in hardware. See the Hardware Setup and Parameter Configuration pages in this documentation for instructions on how to perform all preflight configuration before the aircraft will arm. As a quick help, here is a roslaunch file which quickly does all the above rosrun steps automatically: launch arg name= mav_name value= multirotor / arg name= color default= White / arg name= x default= 0 / arg name= y default= 0 / arg name= z default= 0.2 / arg name= yaw default= 0 / arg name= paused default= false / arg name= gui default= true / arg name= verbose default= false / arg name= debug default= false / include file= $(find rosflight_sim)/launch/base.launch arg name= mav_name value= $(arg mav_name) / arg name= color value= $(arg color) / arg name= x value= $(arg x) / arg name= y value= $(arg y) / arg name= z value= $(arg z) / arg name= yaw value= $(arg yaw) / arg name= paused value= $(arg paused) / arg name= gui value= $(arg gui) / arg name= verbose value= $(arg verbose) / arg name= debug value= $(arg debug) / arg name= xacro_file value= $(find rosflight_sim)/xacro/multirotor.urdf.xacro / arg name= param_file value= $(find rosflight_sim)/params/multirotor.yaml / /include node name= rosflight_io pkg= rosflight type= rosflight_io output= screen param name= udp value= true / /node node name= rc_joy pkg= rosflight_joy type= rc_joy remap from= RC to= multirotor/RC / /node /launch To simulate a fixed-wing mav, just change all instances of multirotor in the above steps to fixedwing .","title":"Running Gazebo Simulation"},{"location":"user-guide/gazebo_simulation/#running-simulations-in-gazebo","text":"Rosflight comes with a useful tool allowing it to perform software-in-the-loop (SIL) simulations of the ROSflight firmware in gazebo.","title":"Running Simulations in Gazebo"},{"location":"user-guide/gazebo_simulation/#architecture-of-the-sil-simulation","text":"To best mimic the hardware experience of ROSflight, the SIL plugin for Gazebo actually implements the firmware source code as a library. We just implemented a different \"board layer\" which uses gazebo instead of hardware calls for things like imu_read() and pwm_write() . Instead of a serial link over USB to the flight controller, we use a UDP connection bouncing off of localhost to communicate between rosflight_io and the firmware. This means the interface to the SIL plugin is identical to that of hardware. rosflight_io is the main gateway to the firmware in simulation, just as it is in hardware. The following table summarizes the correlation between connections in hardware and simulation: Connection Type Hardware Simulation Serial communications to rosflight_io USB / UART UDP RC PPM Receiver ROS RC topic ( rosflight_msgs/RCRaw ) Motors PWM Gazebo Plugin Sensors SPI/I2C Gazebo Plugin","title":"Architecture of the SIL Simulation"},{"location":"user-guide/gazebo_simulation/#quick-start-guide-to-sil-simulation","text":"create a catkin workspace clone the rosflight metapackage repository from github into your workspace clone submodules of the rosflight metapackage: git submodule update --init --recursive clone the rosflight_joy metapackage repository from github into your workspace install pygame: pip install --user pygame Perform a catkin_make roslaunch rosflight_sim multirotor.launch - This will open up a gazebo simulation, and you should have the following rqt_graph At this point, you can't actually do anything because there is no RC connection and no rosflight_io to talk to the firmware. Let's start by running a rosflight_io node. In a separate terminal, run rosrun rosflight rosflight_io _udp:=true . The udp parameter tells rosflight_io to simulate a serial connection over UDP rather than using the USB connection to hardware Your rqt_graph should look something like the following image. This looks funny because ROS doesn't actually know that there is a UDP connection between rosflight_io and gazebo. There is one, though, and you can test it by echoing any of the topics published by rosflight_io . Spin up a simulated RC connection. The easiest way to do this is with the helper package rosflight_joy . Connect a joystick to the computer (or Taranis transmitter) and run rosrun rosflight_joy rc_joy RC:=/multirotor/RC . This simulates the RC connection in hardware. If everything is mapped correctly, you should now be able to arm, disarm and fly the aircraft in simulation! Note It is much easier to fly with a real transmitter than with an Xbox-type controller. FrSky Taranis and RealFlight transmitters and interlinks are also supported. Non-Xbox joysticks may have incorrect mappings. If your joystick does not work, and you write your own mapping, please contribute back your new joystick mapping! Remember, the SIL tries its best to replicate hardware. That means you have to calibrate and set parameters in the same way you do in hardware. See the Hardware Setup and Parameter Configuration pages in this documentation for instructions on how to perform all preflight configuration before the aircraft will arm. As a quick help, here is a roslaunch file which quickly does all the above rosrun steps automatically: launch arg name= mav_name value= multirotor / arg name= color default= White / arg name= x default= 0 / arg name= y default= 0 / arg name= z default= 0.2 / arg name= yaw default= 0 / arg name= paused default= false / arg name= gui default= true / arg name= verbose default= false / arg name= debug default= false / include file= $(find rosflight_sim)/launch/base.launch arg name= mav_name value= $(arg mav_name) / arg name= color value= $(arg color) / arg name= x value= $(arg x) / arg name= y value= $(arg y) / arg name= z value= $(arg z) / arg name= yaw value= $(arg yaw) / arg name= paused value= $(arg paused) / arg name= gui value= $(arg gui) / arg name= verbose value= $(arg verbose) / arg name= debug value= $(arg debug) / arg name= xacro_file value= $(find rosflight_sim)/xacro/multirotor.urdf.xacro / arg name= param_file value= $(find rosflight_sim)/params/multirotor.yaml / /include node name= rosflight_io pkg= rosflight type= rosflight_io output= screen param name= udp value= true / /node node name= rc_joy pkg= rosflight_joy type= rc_joy remap from= RC to= multirotor/RC / /node /launch To simulate a fixed-wing mav, just change all instances of multirotor in the above steps to fixedwing .","title":"Quick-Start Guide to SIL Simulation"},{"location":"user-guide/getting-started/","text":"Getting Started Reading through the pages in this user guide in order should provide you with the information you need to get a vehicle flying with ROSflight. The following is a summary of the steps you'll need to follow to get your vehicle set up, with links to the corresponding documentation pages: Set up your hardware (fixed-wing or multirotor platform, flight controller, and companion computer) Flash your flight controller with the latest ROSflight firmware Set up your RC transmitter Set up ROS on your companion computer Configure the flight controller for your setup : the configuration checklists below should help guide you through this process Run through your preflight checks Tune the attitude controller gains (multirotors only) Set up autonomous flight via offboard control (optional) Configuration Checklist The following checklists should help you get a new vehicle set up for the first time. This checklist assumes that your hardware is already set up correctly . General Setup Set the FIXED_WING parameter ( 1 if a fixed-wing, 0 if a multirotor) Set the RC_TYPE parameter ( 0 if PPM, 1 if SBUS) Set the MIXER parameter to the appropriate value described in the Hardware Setup page Set the MOTOR_PWM_UPDATE parameter (typically 490 for SimonK ESCs, 50 for standard servos) Make sure your RC transmitter is set up correctly Set up your RC switches If you want to arm/disarm using a switch, set the ARM_CHANNEL parameter to the appropriate channel (0-indexed) If you want to use a switch to enable RC override, set the RC_ATT_OVRD_CHN and RC_THR_OVRD_CHN parameters to the appropriate channel(s) (0-indexed). If you want complete control (attitude and throttle) when you flip the switch, set both these parameters to the same channel. Calibrate your IMU: start rosflight_io , then run rosservice call /calibrate_imu Complete the multirotor-specific or fixed-wing-specific checklist below Save the parameters ( rosservice call /param_write ) You'll probably want to save a backup of your parameters (call rosservice call /param_save_to_file /path/to/file.yml ) Make sure you run through the Preflight Checklist before flying Multirotor-specific Setup Danger IMPORTANT: Remove all props from the vehicle when calibrating ESCs!!! Calibrate ESCs Make sure MOTOR_MIN_PWM and MOTOR_MAX_PWM are correct (usually 1000 and 2000 ) Set MIXER param to 0 (ESC calibration mixer) Set ARM_SPIN_MOTORS to 0 Perform ESC calibration. For standard ESCs: With power disconnected from the motors, arm the flight controller Set throttle to maximum Connect power to the motors Drop the throttle to minimum Set the MIXER parameter back to the appropriate value for your vehicle (see the Hardware Setup page) Set ARM_SPIN_MOTORS back to 1 The ARM_SPIN_MOTORS parameter should be set to 1 so the motors spin slowly when armed. The idle throttle setting can be adjusted with the MOTOR_IDLE_THR parameter. You'll most likely want to set the CAL_GYRO_ARM param to 1 to enable calibrating gyros before arming Set the RC_ATT_MODE parameter to set RC control mode ( 0 for rate mode, 1 for angle mode [default]) Set torque offsets as described in the RC trim calculation section of the Improving Performance page Tune the controller gains as described in the Multirotor gain tuning section of the Improving Performance page Fixed-Wing-Specific Setup Reverse servo directions if necessary using the AIL_REV , ELEVATOR_REV , and RUDDER_REV parameters ( 1 to reverse, 0 to keep current direction) You'll most likely want to set the ARM_SPIN_MOTORS parameter to 0 so that the prop doesn't spin at a minimum throttle setting when you arm, especially if you'll be doing hand launching","title":"Getting Started"},{"location":"user-guide/getting-started/#getting-started","text":"Reading through the pages in this user guide in order should provide you with the information you need to get a vehicle flying with ROSflight. The following is a summary of the steps you'll need to follow to get your vehicle set up, with links to the corresponding documentation pages: Set up your hardware (fixed-wing or multirotor platform, flight controller, and companion computer) Flash your flight controller with the latest ROSflight firmware Set up your RC transmitter Set up ROS on your companion computer Configure the flight controller for your setup : the configuration checklists below should help guide you through this process Run through your preflight checks Tune the attitude controller gains (multirotors only) Set up autonomous flight via offboard control (optional)","title":"Getting Started"},{"location":"user-guide/getting-started/#configuration-checklist","text":"The following checklists should help you get a new vehicle set up for the first time. This checklist assumes that your hardware is already set up correctly .","title":"Configuration Checklist"},{"location":"user-guide/getting-started/#general-setup","text":"Set the FIXED_WING parameter ( 1 if a fixed-wing, 0 if a multirotor) Set the RC_TYPE parameter ( 0 if PPM, 1 if SBUS) Set the MIXER parameter to the appropriate value described in the Hardware Setup page Set the MOTOR_PWM_UPDATE parameter (typically 490 for SimonK ESCs, 50 for standard servos) Make sure your RC transmitter is set up correctly Set up your RC switches If you want to arm/disarm using a switch, set the ARM_CHANNEL parameter to the appropriate channel (0-indexed) If you want to use a switch to enable RC override, set the RC_ATT_OVRD_CHN and RC_THR_OVRD_CHN parameters to the appropriate channel(s) (0-indexed). If you want complete control (attitude and throttle) when you flip the switch, set both these parameters to the same channel. Calibrate your IMU: start rosflight_io , then run rosservice call /calibrate_imu Complete the multirotor-specific or fixed-wing-specific checklist below Save the parameters ( rosservice call /param_write ) You'll probably want to save a backup of your parameters (call rosservice call /param_save_to_file /path/to/file.yml ) Make sure you run through the Preflight Checklist before flying","title":"General Setup"},{"location":"user-guide/getting-started/#multirotor-specific-setup","text":"Danger IMPORTANT: Remove all props from the vehicle when calibrating ESCs!!! Calibrate ESCs Make sure MOTOR_MIN_PWM and MOTOR_MAX_PWM are correct (usually 1000 and 2000 ) Set MIXER param to 0 (ESC calibration mixer) Set ARM_SPIN_MOTORS to 0 Perform ESC calibration. For standard ESCs: With power disconnected from the motors, arm the flight controller Set throttle to maximum Connect power to the motors Drop the throttle to minimum Set the MIXER parameter back to the appropriate value for your vehicle (see the Hardware Setup page) Set ARM_SPIN_MOTORS back to 1 The ARM_SPIN_MOTORS parameter should be set to 1 so the motors spin slowly when armed. The idle throttle setting can be adjusted with the MOTOR_IDLE_THR parameter. You'll most likely want to set the CAL_GYRO_ARM param to 1 to enable calibrating gyros before arming Set the RC_ATT_MODE parameter to set RC control mode ( 0 for rate mode, 1 for angle mode [default]) Set torque offsets as described in the RC trim calculation section of the Improving Performance page Tune the controller gains as described in the Multirotor gain tuning section of the Improving Performance page","title":"Multirotor-specific Setup"},{"location":"user-guide/getting-started/#fixed-wing-specific-setup","text":"Reverse servo directions if necessary using the AIL_REV , ELEVATOR_REV , and RUDDER_REV parameters ( 1 to reverse, 0 to keep current direction) You'll most likely want to set the ARM_SPIN_MOTORS parameter to 0 so that the prop doesn't spin at a minimum throttle setting when you arm, especially if you'll be doing hand launching","title":"Fixed-Wing-Specific Setup"},{"location":"user-guide/hardware-setup/","text":"Hardware Setup Parts List To use ROSflight to its full potential, you will need the following system components. Some components are mounted on your MAV (Miniature Aerial Vehicle), while others are on the ground. ROSflight supports both multirotor and fixed-wing vehicles. Mounted on the MAV Aircraft Frame, Motor(s), ESC(s), Battery and Propeller(s) Flight Controller (FC) Vibration Isolation for FC Any external sensors R/C Receiver Companion Computer Wi-Fi Antenna, or access of some kind to ground-station, wireless network (e.g. Ubiquiti Bullet) Ground Station Ground-Station, Wireless Network (e.g. Wi-Fi Router, Ubiquiti Rocket) R/C transmitter Laptop or base station computer Joystick (Xbox controller) Frame, Motors, ESCs, Battery, and Propeller We do not officially support any specific multirotor or airplane frame, motor, ESC, Battery or Propeller combination. There are a lot of great resources for building your own MAV, and there are a lot of great kits out there that have all of these parts. If you are designing your own multirotor or airplane, you may want to look at ecalc , an online tool which can help you design a proper ESC/Battery/Motor/Propeller system for your MAV. Some things to keep in mind as you design or build your MAV. Most kits do not include space for a companion computer, cameras, laser scanners or other sensors. Be sure to think about where these components are going to go, and how their placement will affect the CG of the MAV. You will likely also need to customize the power circuitry of your MAV to provide power to your companion computer at some specific voltage. Many people like to separate the power electronics (the ESCs and motors), from the computer and companion sensors. This can really come in handy if you are trying to develop code on the MAV, because you can have the computer on and sensors powered, and not worry at all about propellers turning on and causing injury as you move the aircraft about by hand. We will talk about this more when we talk about wiring up your MAV. Cheap propellers can cause a huge amount of vibration. Consider buying high-quality propellers, doing a propeller balance, or both. RCGroups, DIY Drones and Youtube have some awesome guides on how to do propeller balancing. ESCs will need to be calibrated from 2000 to 1000 us Flight Controller ROSflight is best supported on the Openpilot Revolution from hobbyking.com . It works on most variants of the Revo and Naze32 flight controller. Configuring a new board is relatively straight-forward, assuming that the board uses an STM32F4xx or STM32F1xx processor. Warning Deprecation Notice: As of June 2019, plans are to deprecate support for the F1 in the near future. If you need to use an F1, you will need to retrieve an older version of the code that supports the F1. However, if there are issues, we will not be able to help you fix them. Warning We have seen some problems using off-brand versions of flight controllers because the accelerometers are of very poor quality, which can mess with the firmware; try to avoid those if you can. External Sensors Additional Sensors you may want for your ROSflight setup include: Sonar - MB1242 I2CXL-MaxSonar - $40 on MaxBotix GPS \u2013 u-blox NEO-M8N \u2013 $35 from Drotek Digital Airspeed Sensor \u2013 $65 on JDrones Vibration Isolation It is really important to isolate your flight controller from vehicle vibrations, such as those caused by propellers and motors. We recommend using small amounts of Kyosho Zeal to mount a fiberglass plate holding the FC to the MAV. You may also want to try adding mass to the flight control board. We have accomplished this by gluing steel washers to the fiberglass mounting plate. You may need to experiment with the amount of gel you use, how far apart the gel is spaced, and the amount of mass added to the FC mounting plate. The interaction of these factors is difficult to predict, therefore it takes a little bit of experimentation to get it right. Companion Computer The only requirement for the companion computer is that it runs Linux (Ubuntu LTS versions 16.04 or 18.04), ROS, has at least one USB port, and can be carried by the aircraft. We have had success with the following companion computers, but by no means is this a comprehensive list; it is more by way of suggestion. MSI CUBI \u2013 i7-5500U \u2013 $350 on Amazon GIGABYTE BRIX Gaming- i7-4710HQ/GTX 760 \u2013 $850 on Amazon Intel NUC Skullcanyon \u2013 i7-6770HQ \u2013 $570 on Amazon ODROID-XU4 \u2013 Exynos5 2GHz 8-core \u2013 $77 on Ameridroid ODROID-C2 \u2013 Cortex A53 2GHz 4-core \u2013 $42 on Ameridroid Rasberry Pi 3 \u2013 Cortex A53 1.2GHz 4-core \u2013 $36 on Amazon NVIDIA Tegra TX1 - Cortex-A57 4-core CPU, 256-core Maxwell GPU - $435 from NVIDA (Educational Discounts Available) NVIDIA Tegra TX2 - 6-core ARMv8 64-bit CPU (4-core Cortex-A57, 2-core NVIDIA Denver 2), 8GB RAM, 256-core Pascal GPU - $600 from NVIDA (Educational Discounts Available) It is possible to pair the TX1 and TX2 with a CTI Orbitty carrier board for more compact builds. Wi-Fi You will need Wi-Fi to communicate with your MAV when it is in the air. Because ROS communicates over TCP, it is very easy to use ROS to view what is going on in your MAV while it is flying by sending commands and reading sensor data. For most applications, a standard Wi-Fi router and dongle will suffice. For long-range applications, you may want to look into Ubiquiti point-to-point Wi-Fi. (We have seen ranges over a mile with these networks.) RC Transmitter and Receiver For RC Control, you will need a transmitter with between 6 and 8 channels. Any additional channels will be wasted. We require RC control for safe operation, and only support arming and disarming via RC control. ROSflight only supports PPM (pulse position modulation) and SBUS receivers. Individual channel PWM outputs are not supported. A common RC setup is listed here, but is meant as an example. Any configurations with PPM or SBUS and 6-8 channels will be sufficient. Transmitter \u2013 FrSky Taranis QX7 ($105 on getfpv.com) Receiver \u2013 FrSky D4R-II (24.99 on getfpv.com) Laptop or Base Station Computer You will need a laptop which can run Ubuntu 16.04 or 18.04 with ROS to communicate with the MAV over the ground station wireless network. If you are new to Linux, and want to retain access to Windows, I would recommend dual booting your computer rather than using a virtual machine. ROS networking can be problematic from a virtual environment. Joystick A joystick is used for software-in-the-loop (SIL) simulations . The joystick is not technically a required component because it is possible to control your MAV from the command line, but it makes things much easier. Our first recommendation is to use the same Taranis QX7 transmitter you use for hardware as a joystick by plugging it into the computer via USB. We also support RealFlight controllers and XBOX 360 controllers. Other joysticks are supported, but you may need to create custom axis and button mappings. Wiring Diagram Below is an example wiring diagram for a multirotor using an MSI Cubi as a companion computer. This diagram also includes the motor power switch, which allows for the sensors, flight controller, and companion computer to be powered on while the motors are off. This is a safer way to test sensors, code, etc. as the motors are unable to spin while the switch is off. Your needs will likely be slightly different than what is shown. This is meant as an example only and can be adapted to fit your needs. Motor Layouts The desired mixer can be chosen by setting the MIXER parameter to the following values: # Mixer 0 ESC calibration 1 Quad + 2 Quad X 3 Hex + 4 Hex X 5 Octo + 6 Octo X 7 Y6 8 X8 9 Tricopter 10 Fixed-wing (traditional AETR) The associated motor layouts are shown below for each mixer. The ESC calibration mixer directly outputs the throttle command equally to each motor, and can be used for calibrating the ESCs. Connecting to the Flight Controller The flight controller communicates with the companion computer over a serial link. ROSflight only supports one serial connection at a time and by default should be the serial link connected to the USB connector on the board. Using Secondary Serial Links In the case of an F4 flight controller, which has a USB peripheral, the highest bandwidth connection will be the USB connector. However, UART3 can also be used to communicate with the companion computer if you desire a more secure connection (micro USB connectors have been known to disconnect in high vibrations), or if you would like to use a telemetry radio for remote control. If a USB connection is detected on the USB peripheral, ROSflight will direct all communication through this port. However, if the PARAM_SERIAL_DEVICE parameter is set to 3 and the PARAM_BAUD_RATE parameter is set properly, then UART3 will be enabled when the USB connection is absent. We have had the most sucess with the SiK radios (AKA 3DR telemetry radios). These require a 5V supply and ground and connect directly to the UART3 pins. We like the SiK radios because they can be easily configured using the AT-commands , which are used by MissionPlanner (Windows only), sikset.py or with the AT-commands directly on the command line. There are a number of configuration options available which should be used to optimize the radios for their intended usage. This is just an example; any UART-based communication interface should be supported through this interface.","title":"Hardware Setup"},{"location":"user-guide/hardware-setup/#hardware-setup","text":"","title":"Hardware Setup"},{"location":"user-guide/hardware-setup/#parts-list","text":"To use ROSflight to its full potential, you will need the following system components. Some components are mounted on your MAV (Miniature Aerial Vehicle), while others are on the ground. ROSflight supports both multirotor and fixed-wing vehicles. Mounted on the MAV Aircraft Frame, Motor(s), ESC(s), Battery and Propeller(s) Flight Controller (FC) Vibration Isolation for FC Any external sensors R/C Receiver Companion Computer Wi-Fi Antenna, or access of some kind to ground-station, wireless network (e.g. Ubiquiti Bullet) Ground Station Ground-Station, Wireless Network (e.g. Wi-Fi Router, Ubiquiti Rocket) R/C transmitter Laptop or base station computer Joystick (Xbox controller)","title":"Parts List"},{"location":"user-guide/hardware-setup/#frame-motors-escs-battery-and-propeller","text":"We do not officially support any specific multirotor or airplane frame, motor, ESC, Battery or Propeller combination. There are a lot of great resources for building your own MAV, and there are a lot of great kits out there that have all of these parts. If you are designing your own multirotor or airplane, you may want to look at ecalc , an online tool which can help you design a proper ESC/Battery/Motor/Propeller system for your MAV. Some things to keep in mind as you design or build your MAV. Most kits do not include space for a companion computer, cameras, laser scanners or other sensors. Be sure to think about where these components are going to go, and how their placement will affect the CG of the MAV. You will likely also need to customize the power circuitry of your MAV to provide power to your companion computer at some specific voltage. Many people like to separate the power electronics (the ESCs and motors), from the computer and companion sensors. This can really come in handy if you are trying to develop code on the MAV, because you can have the computer on and sensors powered, and not worry at all about propellers turning on and causing injury as you move the aircraft about by hand. We will talk about this more when we talk about wiring up your MAV. Cheap propellers can cause a huge amount of vibration. Consider buying high-quality propellers, doing a propeller balance, or both. RCGroups, DIY Drones and Youtube have some awesome guides on how to do propeller balancing. ESCs will need to be calibrated from 2000 to 1000 us","title":"Frame, Motors, ESCs, Battery, and Propeller"},{"location":"user-guide/hardware-setup/#flight-controller","text":"ROSflight is best supported on the Openpilot Revolution from hobbyking.com . It works on most variants of the Revo and Naze32 flight controller. Configuring a new board is relatively straight-forward, assuming that the board uses an STM32F4xx or STM32F1xx processor. Warning Deprecation Notice: As of June 2019, plans are to deprecate support for the F1 in the near future. If you need to use an F1, you will need to retrieve an older version of the code that supports the F1. However, if there are issues, we will not be able to help you fix them. Warning We have seen some problems using off-brand versions of flight controllers because the accelerometers are of very poor quality, which can mess with the firmware; try to avoid those if you can.","title":"Flight Controller"},{"location":"user-guide/hardware-setup/#external-sensors","text":"Additional Sensors you may want for your ROSflight setup include: Sonar - MB1242 I2CXL-MaxSonar - $40 on MaxBotix GPS \u2013 u-blox NEO-M8N \u2013 $35 from Drotek Digital Airspeed Sensor \u2013 $65 on JDrones","title":"External Sensors"},{"location":"user-guide/hardware-setup/#vibration-isolation","text":"It is really important to isolate your flight controller from vehicle vibrations, such as those caused by propellers and motors. We recommend using small amounts of Kyosho Zeal to mount a fiberglass plate holding the FC to the MAV. You may also want to try adding mass to the flight control board. We have accomplished this by gluing steel washers to the fiberglass mounting plate. You may need to experiment with the amount of gel you use, how far apart the gel is spaced, and the amount of mass added to the FC mounting plate. The interaction of these factors is difficult to predict, therefore it takes a little bit of experimentation to get it right.","title":"Vibration Isolation"},{"location":"user-guide/hardware-setup/#companion-computer","text":"The only requirement for the companion computer is that it runs Linux (Ubuntu LTS versions 16.04 or 18.04), ROS, has at least one USB port, and can be carried by the aircraft. We have had success with the following companion computers, but by no means is this a comprehensive list; it is more by way of suggestion. MSI CUBI \u2013 i7-5500U \u2013 $350 on Amazon GIGABYTE BRIX Gaming- i7-4710HQ/GTX 760 \u2013 $850 on Amazon Intel NUC Skullcanyon \u2013 i7-6770HQ \u2013 $570 on Amazon ODROID-XU4 \u2013 Exynos5 2GHz 8-core \u2013 $77 on Ameridroid ODROID-C2 \u2013 Cortex A53 2GHz 4-core \u2013 $42 on Ameridroid Rasberry Pi 3 \u2013 Cortex A53 1.2GHz 4-core \u2013 $36 on Amazon NVIDIA Tegra TX1 - Cortex-A57 4-core CPU, 256-core Maxwell GPU - $435 from NVIDA (Educational Discounts Available) NVIDIA Tegra TX2 - 6-core ARMv8 64-bit CPU (4-core Cortex-A57, 2-core NVIDIA Denver 2), 8GB RAM, 256-core Pascal GPU - $600 from NVIDA (Educational Discounts Available) It is possible to pair the TX1 and TX2 with a CTI Orbitty carrier board for more compact builds.","title":"Companion Computer"},{"location":"user-guide/hardware-setup/#wi-fi","text":"You will need Wi-Fi to communicate with your MAV when it is in the air. Because ROS communicates over TCP, it is very easy to use ROS to view what is going on in your MAV while it is flying by sending commands and reading sensor data. For most applications, a standard Wi-Fi router and dongle will suffice. For long-range applications, you may want to look into Ubiquiti point-to-point Wi-Fi. (We have seen ranges over a mile with these networks.)","title":"Wi-Fi"},{"location":"user-guide/hardware-setup/#rc-transmitter-and-receiver","text":"For RC Control, you will need a transmitter with between 6 and 8 channels. Any additional channels will be wasted. We require RC control for safe operation, and only support arming and disarming via RC control. ROSflight only supports PPM (pulse position modulation) and SBUS receivers. Individual channel PWM outputs are not supported. A common RC setup is listed here, but is meant as an example. Any configurations with PPM or SBUS and 6-8 channels will be sufficient. Transmitter \u2013 FrSky Taranis QX7 ($105 on getfpv.com) Receiver \u2013 FrSky D4R-II (24.99 on getfpv.com)","title":"RC Transmitter and Receiver"},{"location":"user-guide/hardware-setup/#laptop-or-base-station-computer","text":"You will need a laptop which can run Ubuntu 16.04 or 18.04 with ROS to communicate with the MAV over the ground station wireless network. If you are new to Linux, and want to retain access to Windows, I would recommend dual booting your computer rather than using a virtual machine. ROS networking can be problematic from a virtual environment.","title":"Laptop or Base Station Computer"},{"location":"user-guide/hardware-setup/#joystick","text":"A joystick is used for software-in-the-loop (SIL) simulations . The joystick is not technically a required component because it is possible to control your MAV from the command line, but it makes things much easier. Our first recommendation is to use the same Taranis QX7 transmitter you use for hardware as a joystick by plugging it into the computer via USB. We also support RealFlight controllers and XBOX 360 controllers. Other joysticks are supported, but you may need to create custom axis and button mappings.","title":"Joystick"},{"location":"user-guide/hardware-setup/#wiring-diagram","text":"Below is an example wiring diagram for a multirotor using an MSI Cubi as a companion computer. This diagram also includes the motor power switch, which allows for the sensors, flight controller, and companion computer to be powered on while the motors are off. This is a safer way to test sensors, code, etc. as the motors are unable to spin while the switch is off. Your needs will likely be slightly different than what is shown. This is meant as an example only and can be adapted to fit your needs.","title":"Wiring Diagram"},{"location":"user-guide/hardware-setup/#motor-layouts","text":"The desired mixer can be chosen by setting the MIXER parameter to the following values: # Mixer 0 ESC calibration 1 Quad + 2 Quad X 3 Hex + 4 Hex X 5 Octo + 6 Octo X 7 Y6 8 X8 9 Tricopter 10 Fixed-wing (traditional AETR) The associated motor layouts are shown below for each mixer. The ESC calibration mixer directly outputs the throttle command equally to each motor, and can be used for calibrating the ESCs.","title":"Motor Layouts"},{"location":"user-guide/hardware-setup/#connecting-to-the-flight-controller","text":"The flight controller communicates with the companion computer over a serial link. ROSflight only supports one serial connection at a time and by default should be the serial link connected to the USB connector on the board.","title":"Connecting to the Flight Controller"},{"location":"user-guide/hardware-setup/#using-secondary-serial-links","text":"In the case of an F4 flight controller, which has a USB peripheral, the highest bandwidth connection will be the USB connector. However, UART3 can also be used to communicate with the companion computer if you desire a more secure connection (micro USB connectors have been known to disconnect in high vibrations), or if you would like to use a telemetry radio for remote control. If a USB connection is detected on the USB peripheral, ROSflight will direct all communication through this port. However, if the PARAM_SERIAL_DEVICE parameter is set to 3 and the PARAM_BAUD_RATE parameter is set properly, then UART3 will be enabled when the USB connection is absent. We have had the most sucess with the SiK radios (AKA 3DR telemetry radios). These require a 5V supply and ground and connect directly to the UART3 pins. We like the SiK radios because they can be easily configured using the AT-commands , which are used by MissionPlanner (Windows only), sikset.py or with the AT-commands directly on the command line. There are a number of configuration options available which should be used to optimize the radios for their intended usage. This is just an example; any UART-based communication interface should be supported through this interface.","title":"Using Secondary Serial Links"},{"location":"user-guide/overview/","text":"Overview This page provides an overview of the basic operation of the ROSflight firmware and the concepts behind the behaviors. Companion Computer ROSflight is primarily intended to be used with a companion computer running ROS. The ROS interface is provided by the rosflight_io node. All configuration of the flight controller is done through the ROS service API provided by rosflight_io (see the parameter configuration documentation page). Sensor data such as IMU measurements are streamed from the flight controller to the companion computer and published as ROS topics. Control setpoints can also be sent to the flight controller by publishing to the appropriate ROS topic (see the autonomous flight documentation page). Note To avoid confusion, we try to consistently use the following terminology: Flight controller: The embedded board (such as a Revo or Naze32) that runs the ROSflight firmware and performs I/O with sensors and ESCs Companion computer: A Linux computer, running ROS, that is mounted on the vehicle and has a physical, serial connection with the flight controller Offboard control (setpoints): The control setpoints passed from the companion computer to the flight controller. The control is \"offboard\" from the perspective of the flight controller, even though the computer providing those commands is mounted onboard the vehicle. Perhaps this is not the greatest terminology, but hopefully this helps clear up potential confusion. The following figure illustrates the interactions between the major components of the system: RC Safety Pilot ROSflight is designed for use with offboard control from experimental and research code. As such, it provides several mechanisms for an RC safety pilot to intervene if something goes wrong with the control setpoints coming from the companion computer: RC override switch: The safety pilot can flip a switch on the transmitter to take back RC control. Attitude and throttle override can be mapped independently, meaning you can choose one or the other, put them on separate switches, or put them both on the same switch. Details on these switches are provided on the RC configuration page. Stick deviations: If a stick is deviated from its center position, then that channel is overridden by RC control. This allows the safety pilot to take control without flipping a switch. This may be useful to provide a momentary correction on a single axis. The fraction of stick travel needed to activate the RC override is controlled by the RC_OVRD_DEV parameter. The OVRD_LAG_TIME parameter controls the amount of time that the override remains active after the sticks return to center. Minimum throttle: By default, the flight controller takes the minimum of the two throttle commands from RC and offboard control setpoints. This allows the safety pilot to drop the throttle quickly if needed. This behavior can be turned on or off with the MIN_THROTTLE parameter. Arming, Errors Failsafe The flight controller can only be armed and disarmed via RC control. Two mechanisms are provided: sticks (left stick down and right to arm, down and left to disarm) and switch. Only one of these options can be active at a time. Details on configuration are given on the RC configuration page. The firmware runs a number of error checks before allowing the flight controller to arm. Completing the configuration checklist on the Getting Started page should avoid these errors. In addition to a few internal health checks, the following conditions are checked: Mixer: Valid mixer must have been selected (see the Hardware Setup documentation page) IMU calibration: The IMU must have been calibrated since firmware was flashed (it is recommended that you recalibrate often) RC: There must be an active RC connection In addition to the error checking before arming, the flight controller enters a failsafe mode if the RC connection is lost during flight while armed. While in failsafe mode the flight controller commands level flight with the throttle value defined by the FAILSAFE_THR parameter. The following is a simplified version of the finite state machine that defines logic used for the arming, error checks, and failsafe operations: LEDs The meaning of the various LEDs is summarized in the following table. The colors of the LEDs may change depending on your specific board: LED On Off Slow Blink Fast Blink Power (Blue) Board powered - - - Info (Green) RC control Offboard control - - Warning (Red) Armed Disarmed Error (disarmed) Failsafe (armed)","title":"Overview"},{"location":"user-guide/overview/#overview","text":"This page provides an overview of the basic operation of the ROSflight firmware and the concepts behind the behaviors.","title":"Overview"},{"location":"user-guide/overview/#companion-computer","text":"ROSflight is primarily intended to be used with a companion computer running ROS. The ROS interface is provided by the rosflight_io node. All configuration of the flight controller is done through the ROS service API provided by rosflight_io (see the parameter configuration documentation page). Sensor data such as IMU measurements are streamed from the flight controller to the companion computer and published as ROS topics. Control setpoints can also be sent to the flight controller by publishing to the appropriate ROS topic (see the autonomous flight documentation page). Note To avoid confusion, we try to consistently use the following terminology: Flight controller: The embedded board (such as a Revo or Naze32) that runs the ROSflight firmware and performs I/O with sensors and ESCs Companion computer: A Linux computer, running ROS, that is mounted on the vehicle and has a physical, serial connection with the flight controller Offboard control (setpoints): The control setpoints passed from the companion computer to the flight controller. The control is \"offboard\" from the perspective of the flight controller, even though the computer providing those commands is mounted onboard the vehicle. Perhaps this is not the greatest terminology, but hopefully this helps clear up potential confusion. The following figure illustrates the interactions between the major components of the system:","title":"Companion Computer"},{"location":"user-guide/overview/#rc-safety-pilot","text":"ROSflight is designed for use with offboard control from experimental and research code. As such, it provides several mechanisms for an RC safety pilot to intervene if something goes wrong with the control setpoints coming from the companion computer: RC override switch: The safety pilot can flip a switch on the transmitter to take back RC control. Attitude and throttle override can be mapped independently, meaning you can choose one or the other, put them on separate switches, or put them both on the same switch. Details on these switches are provided on the RC configuration page. Stick deviations: If a stick is deviated from its center position, then that channel is overridden by RC control. This allows the safety pilot to take control without flipping a switch. This may be useful to provide a momentary correction on a single axis. The fraction of stick travel needed to activate the RC override is controlled by the RC_OVRD_DEV parameter. The OVRD_LAG_TIME parameter controls the amount of time that the override remains active after the sticks return to center. Minimum throttle: By default, the flight controller takes the minimum of the two throttle commands from RC and offboard control setpoints. This allows the safety pilot to drop the throttle quickly if needed. This behavior can be turned on or off with the MIN_THROTTLE parameter.","title":"RC Safety Pilot"},{"location":"user-guide/overview/#arming-errors-failsafe","text":"The flight controller can only be armed and disarmed via RC control. Two mechanisms are provided: sticks (left stick down and right to arm, down and left to disarm) and switch. Only one of these options can be active at a time. Details on configuration are given on the RC configuration page. The firmware runs a number of error checks before allowing the flight controller to arm. Completing the configuration checklist on the Getting Started page should avoid these errors. In addition to a few internal health checks, the following conditions are checked: Mixer: Valid mixer must have been selected (see the Hardware Setup documentation page) IMU calibration: The IMU must have been calibrated since firmware was flashed (it is recommended that you recalibrate often) RC: There must be an active RC connection In addition to the error checking before arming, the flight controller enters a failsafe mode if the RC connection is lost during flight while armed. While in failsafe mode the flight controller commands level flight with the throttle value defined by the FAILSAFE_THR parameter. The following is a simplified version of the finite state machine that defines logic used for the arming, error checks, and failsafe operations:","title":"Arming, Errors &amp; Failsafe"},{"location":"user-guide/overview/#leds","text":"The meaning of the various LEDs is summarized in the following table. The colors of the LEDs may change depending on your specific board: LED On Off Slow Blink Fast Blink Power (Blue) Board powered - - - Info (Green) RC control Offboard control - - Warning (Red) Armed Disarmed Error (disarmed) Failsafe (armed)","title":"LEDs"},{"location":"user-guide/parameter-configuration/","text":"Parameters The ROSflight firmware has several dozen parameters which it uses to customize performance. Parameters are considered semi-static variables. That is, parameters do not change during flight, but they may change between vehicles. Examples of parameters you may wish to change are: Fixed-wing vehicle flag PID gains Mixer choice IMU low-pass filter constant RC receiver type (PPM or SBUS) and so on. Access to all parameters is enabled via ROS services advertised by rosflight_io while the flight controller is connected. Parameter Interface Getting Parameter Values Sometimes it is handy to ask the flight controller what the current value of a parameter is. This is accomplished using the param_get service. As an example, let's retrieve the roll angle controller proportional (P) gain. rosservice call /param_get PID_ROLL_ANG_P You should get a response similar to the following (this happens to be the default value with floating-point error): exists: True value: 0.15000000596 Changing Parameters Parameters are changed via the param_set service. As an example, let's change the roll angle controller P gain. (I will assume that the flight controller is connected and rosflight_io is running in the root namespace.) rosservice call /param_set PID_ROLL_ANG_P 0.08 You should get a prompt from rosflight_io saying [ INFO] [1491672408.585339558]: Parameter PID_ROLL_ANG_P has new value 0.08 [ WARN] [1491672408.585508849]: There are unsaved changes to onboard parameters Notice that the parameters have been set, but not saved. Parameter changes take effect immediately, however they will not persist over a reboot unless you write them to the non-volatile memory. This brings us to the next task. Writing Parameters To ensure that parameter values persist between reboots, you must write the parameters to the non-volatile memory. This is done by calling param_write rosservice call /param_write Error Parameter writing can only happen if the flight controller is disarmed. If the param write failed for some reason, you may want to make sure your FC is disarmed and try again. Backing Up and Loading Parameters from File It is good practice to backup your parameter configuration in case you have to re-flash your firmware or you want to share configurations between vehicles. We can do this via the param_save_to_file and param_load_from_file services. First, let's back up our current parameter configuration: rosservice call /param_save_to_file ~/parameters.yml Parameters are saved in YAML format. You must also specify the absolute file name of where you would like your parameters to be saved. The current active set of parameters will be saved, regardless of what is saved in non-volatile memory on the flight controller. Now, let's say we want to re-load this parameter file rosservice call /param_load_from_file ~/parameters.yml Again, you must specify the absolute file name of the file to be loaded. Fixed-Wing Parameter Configuration Because ROSflight ships with default parameters for multirotors, you will probably want to change the following parameters if you want to fly a fixed-wing aircraft. Parameter Description Type Fixed-Wing Value MOTOR_PWM_UPDATE Refresh rate of motor commands to motors and servos (Hz) - See motor documentation int 50 ARM_SPIN_MOTORS Enforce MOTOR_IDLE_PWM int false MOTOR_IDLE_THR min throttle command sent to motors when armed (Set above 0.1 to spin when armed) float 0.1 ARM_CHANNEL RC switch channel mapped to arming [0 indexed, -1 to disable] int 4 FIXED_WING switches on passthrough commands for fixed-wing operation int true MIXER Which mixer to choose - See Mixer documentation int 10 ELEVATOR_REV reverses elevator servo output int 0/1 AIL_REV reverses aileron servo output int 0/1 RUDDER_REV reverses rudder servo output int 0/1 CAL_GYRO_ARM Calibrate gyros when arming - generally only for multirotors int false Description of all Parameters This is a list of all ROSflight parameters, including their types, default values, and minimum and maximum recommended values: Parameter Description Type Default Value Min Max BAUD_RATE Baud rate of MAVlink communication with companion computer int 921600 9600 921600 SERIAL_DEVICE Serial Port (for supported devices) int 0 0 3 SYS_ID Mavlink System ID int 1 1 255 STRM_HRTBT Rate of heartbeat stream (Hz) int 1 0 1000 STRM_STATUS Rate of status stream (Hz) int 10 0 1000 STRM_ATTITUDE Rate of attitude stream (Hz) int 200 0 1000 STRM_IMU Rate of IMU stream (Hz) int 250 0 1000 STRM_MAG Rate of magnetometer stream (Hz) int 50 0 75 STRM_BARO Rate of barometer stream (Hz) int 50 0 100 STRM_AIRSPEED Rate of airspeed stream (Hz) int 50 0 50 STRM_SONAR Rate of sonar stream (Hz) int 40 0 40 STRM_SERVO Rate of raw output stream int 50 0 490 STRM_RC Rate of raw RC input stream int 50 0 50 STRM_GNSS Maximum rate of GNSS data streaming. Higher values allow for lower latency int 1000 0 1000 STRM_GNSS_RAW Maximum rate of raw GNSS data streaming int 0 0 10 PARAM_MAX_CMD saturation point for PID controller output float 1.0 0 1.0 PID_ROLL_RATE_P Roll Rate Proportional Gain float 0.070f 0.0 1000.0 PID_ROLL_RATE_I Roll Rate Integral Gain float 0.000f 0.0 1000.0 PID_ROLL_RATE_D Roll Rate Derivative Gain float 0.000f 0.0 1000.0 PID_PITCH_RATE_P Pitch Rate Proportional Gain float 0.070f 0.0 1000.0 PID_PITCH_RATE_I Pitch Rate Integral Gain float 0.0000f 0.0 1000.0 PID_PITCH_RATE_D Pitch Rate Derivative Gain float 0.0000f 0.0 1000.0 PID_YAW_RATE_P Yaw Rate Proportional Gain float 0.25f 0.0 1000.0 PID_YAW_RATE_I Yaw Rate Integral Gain float 0.0f 0.0 1000.0 PID_YAW_RATE_D Yaw Rate Derivative Gain float 0.0f 0.0 1000.0 PID_ROLL_ANG_P Roll Angle Proportional Gain float 0.15f 0.0 1000.0 PID_ROLL_ANG_I Roll Angle Integral Gain float 0.0f 0.0 1000.0 PID_ROLL_ANG_D Roll Angle Derivative Gain float 0.05f 0.0 1000.0 PID_PITCH_ANG_P Pitch Angle Proportional Gain float 0.15f 0.0 1000.0 PID_PITCH_ANG_I Pitch Angle Integral Gain float 0.0f 0.0 1000.0 PID_PITCH_ANG_D Pitch Angle Derivative Gain float 0.05f 0.0 1000.0 X_EQ_TORQUE Equilibrium torque added to output of controller on x axis float 0.0f -1.0 1.0 Y_EQ_TORQUE Equilibrium torque added to output of controller on y axis float 0.0f -1.0 1.0 Z_EQ_TORQUE Equilibrium torque added to output of controller on z axis float 0.0f -1.0 1.0 PID_TAU Dirty Derivative time constant - See controller documentation float 0.05f 0.0 1.0 MOTOR_PWM_UPDATE Overrides default PWM rate specified by mixer if non-zero - Requires reboot to take effect int 0 0 490 MOTOR_IDLE_THR min throttle command sent to motors when armed (Set above 0.1 to spin when armed) float 0.1 0.0 1.0 FAILSAFE_THR Throttle sent to motors in failsafe condition (set just below hover throttle) float 0.3 0.0 1.0 ARM_SPIN_MOTORS Enforce MOTOR_IDLE_THR int true 0 1 FILTER_INIT_T Time in ms to initialize estimator int 3000 0 100000 FILTER_KP estimator proportional gain - See estimator documentation float 0.5f 0 10.0 FILTER_KI estimator integral gain - See estimator documentation float 0.01f 0 1.0 FILTER_KP_COR estimator proportional gain on external attitude correction - See estimator documentation float 10.0f 0 1.0 FILTER_ACCMARGIN allowable accel norm margin around 1g to determine if accel is usable float 0.1f 0 1.0 FILTER_QUAD_INT Perform a quadratic averaging of LPF gyro data prior to integration (adds ~20 us to estimation loop on F1 processors) int 1 0 1 FILTER_MAT_EXP 1 - Use matrix exponential to improve gyro integration (adds ~90 us to estimation loop in F1 processors) 0 - use euler integration int 1 0 1 FILTER_USE_ACC Use accelerometer to correct gyro integration drift (adds ~70 us to estimation loop) int 1 0 1 CAL_GYRO_ARM True if desired to calibrate gyros on arm int false 0 1 GYROXY_LPF_ALPHA Low-pass filter constant on gyro X and Y axes - See estimator documentation float 0.3f 0 1.0 GYROZ_LPF_ALPHA Low-pass filter constant on gyro Z axis - See estimator documentation float 0.3f 0 1.0 ACC_LPF_ALPHA Low-pass filter constant on all accel axes - See estimator documentation float 0.5f 0 1.0 GYRO_X_BIAS Constant x-bias of gyroscope readings float 0.0f -1.0 1.0 GYRO_Y_BIAS Constant y-bias of gyroscope readings float 0.0f -1.0 1.0 GYRO_Z_BIAS Constant z-bias of gyroscope readings float 0.0f -1.0 1.0 ACC_X_BIAS Constant x-bias of accelerometer readings float 0.0f -2.0 2.0 ACC_Y_BIAS Constant y-bias of accelerometer readings float 0.0f -2.0 2.0 ACC_Z_BIAS Constant z-bias of accelerometer readings float 0.0f -2.0 2.0 ACC_X_TEMP_COMP Linear x-axis temperature compensation constant float 0.0f -2.0 2.0 ACC_Y_TEMP_COMP Linear y-axis temperature compensation constant float 0.0f -2.0 2.0 ACC_Z_TEMP_COMP Linear z-axis temperature compensation constant float 0.0f -2.0 2.0 MAG_A11_COMP Soft iron compensation constant float 1.0f -999.0 999.0 MAG_A12_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A13_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A21_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A22_COMP Soft iron compensation constant float 1.0f -999.0 999.0 MAG_A23_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A31_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A32_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A33_COMP Soft iron compensation constant float 1.0f -999.0 999.0 MAG_X_BIAS Hard iron compensation constant float 0.0f -999.0 999.0 MAG_Y_BIAS Hard iron compensation constant float 0.0f -999.0 999.0 MAG_Z_BIAS Hard iron compensation constant float 0.0f -999.0 999.0 BARO_BIAS Barometer measurement bias (Pa) float 0.0f 0 inf GROUND_LEVEL Altitude of ground level (m) float 1387.0f -1000 10000 DIFF_PRESS_BIAS Differential Pressure Bias (Pa) float 0.0f -10 10 RC_TYPE Type of RC input 0 - PPM, 1 - SBUS int 0 0 1 RC_X_CHN RC input channel mapped to x-axis commands [0 - indexed] int 0 0 3 RC_Y_CHN RC input channel mapped to y-axis commands [0 - indexed] int 1 0 3 RC_Z_CHN RC input channel mapped to z-axis commands [0 - indexed] int 3 0 3 RC_F_CHN RC input channel mapped to F-axis commands [0 - indexed] int 2 0 3 RC_ATT_OVRD_CHN RC switch mapped to attitude override [0 indexed, -1 to disable] int 4 4 7 RC_THR_OVRD_CHN RC switch channel mapped to throttle override [0 indexed, -1 to disable] int 4 4 7 RC_ATT_CTRL_CHN RC switch channel mapped to attitude control type [0 indexed, -1 to disable] int -1 4 7 ARM_CHANNEL RC switch channel mapped to arming (only if PARAM_ARM_STICKS is false) [0 indexed, -1 to disable] int -1 4 7 RC_NUM_CHN number of RC input channels int 6 1 8 SWITCH_5_DIR RC switch 5 toggle direction int 1 -1 1 SWITCH_6_DIR RC switch 6 toggle direction int 1 -1 1 SWITCH_7_DIR RC switch 7 toggle direction int 1 -1 1 SWITCH_8_DIR RC switch 8 toggle direction int 1 -1 1 RC_OVRD_DEV RC stick deviation from center for override float 0.1 0.0 1.0 OVRD_LAG_TIME RC stick deviation lag time before returning control (ms) int 1000 0 100000 MIN_THROTTLE Take minimum throttle between RC and computer at all times int true 0 1 RC_ATT_MODE Attitude mode for RC sticks (0: rate, 1: angle). Overridden if RC_ATT_CTRL_CHN is set. int 1 0 1 RC_MAX_ROLL Maximum roll angle command sent by full deflection of RC sticks float 0.786f 0.0 3.14159 RC_MAX_PITCH Maximum pitch angle command sent by full stick deflection of RC sticks float 0.786f 0.0 3.14159 RC_MAX_ROLLRATE Maximum roll rate command sent by full stick deflection of RC sticks float 3.14159f 0.0 9.42477796077 RC_MAX_PITCHRATE Maximum pitch command sent by full stick deflection of RC sticks float 3.14159f 0.0 3.14159 RC_MAX_YAWRATE Maximum pitch command sent by full stick deflection of RC sticks float 1.507f 0.0 3.14159 MIXER Which mixer to choose - See Mixer documentation int Mixer::INVALID_MIXER 0 10 FIXED_WING switches on pass-through commands for fixed-wing operation int false 0 1 ELEVATOR_REV reverses elevator servo output int 0 0 1 AIL_REV reverses aileron servo output int 0 0 1 RUDDER_REV reverses rudder servo output int 0 0 1 FC_ROLL roll angle (deg) of flight controller wrt aircraft body float 0.0f 0 360 FC_PITCH pitch angle (deg) of flight controller wrt aircraft body float 0.0f 0 360 FC_YAW yaw angle (deg) of flight controller wrt aircraft body float 0.0f 0 360 ARM_THRESHOLD RC deviation from max/min in yaw and throttle for arming and disarming check (us) float 0.15 0 500 OFFBOARD_TIMEOUT Timeout in milliseconds for offboard commands, after which RC override is activated int 100 0 100000","title":"Parameter Configuration"},{"location":"user-guide/parameter-configuration/#parameters","text":"The ROSflight firmware has several dozen parameters which it uses to customize performance. Parameters are considered semi-static variables. That is, parameters do not change during flight, but they may change between vehicles. Examples of parameters you may wish to change are: Fixed-wing vehicle flag PID gains Mixer choice IMU low-pass filter constant RC receiver type (PPM or SBUS) and so on. Access to all parameters is enabled via ROS services advertised by rosflight_io while the flight controller is connected.","title":"Parameters"},{"location":"user-guide/parameter-configuration/#parameter-interface","text":"","title":"Parameter Interface"},{"location":"user-guide/parameter-configuration/#getting-parameter-values","text":"Sometimes it is handy to ask the flight controller what the current value of a parameter is. This is accomplished using the param_get service. As an example, let's retrieve the roll angle controller proportional (P) gain. rosservice call /param_get PID_ROLL_ANG_P You should get a response similar to the following (this happens to be the default value with floating-point error): exists: True value: 0.15000000596","title":"Getting Parameter Values"},{"location":"user-guide/parameter-configuration/#changing-parameters","text":"Parameters are changed via the param_set service. As an example, let's change the roll angle controller P gain. (I will assume that the flight controller is connected and rosflight_io is running in the root namespace.) rosservice call /param_set PID_ROLL_ANG_P 0.08 You should get a prompt from rosflight_io saying [ INFO] [1491672408.585339558]: Parameter PID_ROLL_ANG_P has new value 0.08 [ WARN] [1491672408.585508849]: There are unsaved changes to onboard parameters Notice that the parameters have been set, but not saved. Parameter changes take effect immediately, however they will not persist over a reboot unless you write them to the non-volatile memory. This brings us to the next task.","title":"Changing Parameters"},{"location":"user-guide/parameter-configuration/#writing-parameters","text":"To ensure that parameter values persist between reboots, you must write the parameters to the non-volatile memory. This is done by calling param_write rosservice call /param_write Error Parameter writing can only happen if the flight controller is disarmed. If the param write failed for some reason, you may want to make sure your FC is disarmed and try again.","title":"Writing Parameters"},{"location":"user-guide/parameter-configuration/#backing-up-and-loading-parameters-from-file","text":"It is good practice to backup your parameter configuration in case you have to re-flash your firmware or you want to share configurations between vehicles. We can do this via the param_save_to_file and param_load_from_file services. First, let's back up our current parameter configuration: rosservice call /param_save_to_file ~/parameters.yml Parameters are saved in YAML format. You must also specify the absolute file name of where you would like your parameters to be saved. The current active set of parameters will be saved, regardless of what is saved in non-volatile memory on the flight controller. Now, let's say we want to re-load this parameter file rosservice call /param_load_from_file ~/parameters.yml Again, you must specify the absolute file name of the file to be loaded.","title":"Backing Up and Loading Parameters from File"},{"location":"user-guide/parameter-configuration/#fixed-wing-parameter-configuration","text":"Because ROSflight ships with default parameters for multirotors, you will probably want to change the following parameters if you want to fly a fixed-wing aircraft. Parameter Description Type Fixed-Wing Value MOTOR_PWM_UPDATE Refresh rate of motor commands to motors and servos (Hz) - See motor documentation int 50 ARM_SPIN_MOTORS Enforce MOTOR_IDLE_PWM int false MOTOR_IDLE_THR min throttle command sent to motors when armed (Set above 0.1 to spin when armed) float 0.1 ARM_CHANNEL RC switch channel mapped to arming [0 indexed, -1 to disable] int 4 FIXED_WING switches on passthrough commands for fixed-wing operation int true MIXER Which mixer to choose - See Mixer documentation int 10 ELEVATOR_REV reverses elevator servo output int 0/1 AIL_REV reverses aileron servo output int 0/1 RUDDER_REV reverses rudder servo output int 0/1 CAL_GYRO_ARM Calibrate gyros when arming - generally only for multirotors int false","title":"Fixed-Wing Parameter Configuration"},{"location":"user-guide/parameter-configuration/#description-of-all-parameters","text":"This is a list of all ROSflight parameters, including their types, default values, and minimum and maximum recommended values: Parameter Description Type Default Value Min Max BAUD_RATE Baud rate of MAVlink communication with companion computer int 921600 9600 921600 SERIAL_DEVICE Serial Port (for supported devices) int 0 0 3 SYS_ID Mavlink System ID int 1 1 255 STRM_HRTBT Rate of heartbeat stream (Hz) int 1 0 1000 STRM_STATUS Rate of status stream (Hz) int 10 0 1000 STRM_ATTITUDE Rate of attitude stream (Hz) int 200 0 1000 STRM_IMU Rate of IMU stream (Hz) int 250 0 1000 STRM_MAG Rate of magnetometer stream (Hz) int 50 0 75 STRM_BARO Rate of barometer stream (Hz) int 50 0 100 STRM_AIRSPEED Rate of airspeed stream (Hz) int 50 0 50 STRM_SONAR Rate of sonar stream (Hz) int 40 0 40 STRM_SERVO Rate of raw output stream int 50 0 490 STRM_RC Rate of raw RC input stream int 50 0 50 STRM_GNSS Maximum rate of GNSS data streaming. Higher values allow for lower latency int 1000 0 1000 STRM_GNSS_RAW Maximum rate of raw GNSS data streaming int 0 0 10 PARAM_MAX_CMD saturation point for PID controller output float 1.0 0 1.0 PID_ROLL_RATE_P Roll Rate Proportional Gain float 0.070f 0.0 1000.0 PID_ROLL_RATE_I Roll Rate Integral Gain float 0.000f 0.0 1000.0 PID_ROLL_RATE_D Roll Rate Derivative Gain float 0.000f 0.0 1000.0 PID_PITCH_RATE_P Pitch Rate Proportional Gain float 0.070f 0.0 1000.0 PID_PITCH_RATE_I Pitch Rate Integral Gain float 0.0000f 0.0 1000.0 PID_PITCH_RATE_D Pitch Rate Derivative Gain float 0.0000f 0.0 1000.0 PID_YAW_RATE_P Yaw Rate Proportional Gain float 0.25f 0.0 1000.0 PID_YAW_RATE_I Yaw Rate Integral Gain float 0.0f 0.0 1000.0 PID_YAW_RATE_D Yaw Rate Derivative Gain float 0.0f 0.0 1000.0 PID_ROLL_ANG_P Roll Angle Proportional Gain float 0.15f 0.0 1000.0 PID_ROLL_ANG_I Roll Angle Integral Gain float 0.0f 0.0 1000.0 PID_ROLL_ANG_D Roll Angle Derivative Gain float 0.05f 0.0 1000.0 PID_PITCH_ANG_P Pitch Angle Proportional Gain float 0.15f 0.0 1000.0 PID_PITCH_ANG_I Pitch Angle Integral Gain float 0.0f 0.0 1000.0 PID_PITCH_ANG_D Pitch Angle Derivative Gain float 0.05f 0.0 1000.0 X_EQ_TORQUE Equilibrium torque added to output of controller on x axis float 0.0f -1.0 1.0 Y_EQ_TORQUE Equilibrium torque added to output of controller on y axis float 0.0f -1.0 1.0 Z_EQ_TORQUE Equilibrium torque added to output of controller on z axis float 0.0f -1.0 1.0 PID_TAU Dirty Derivative time constant - See controller documentation float 0.05f 0.0 1.0 MOTOR_PWM_UPDATE Overrides default PWM rate specified by mixer if non-zero - Requires reboot to take effect int 0 0 490 MOTOR_IDLE_THR min throttle command sent to motors when armed (Set above 0.1 to spin when armed) float 0.1 0.0 1.0 FAILSAFE_THR Throttle sent to motors in failsafe condition (set just below hover throttle) float 0.3 0.0 1.0 ARM_SPIN_MOTORS Enforce MOTOR_IDLE_THR int true 0 1 FILTER_INIT_T Time in ms to initialize estimator int 3000 0 100000 FILTER_KP estimator proportional gain - See estimator documentation float 0.5f 0 10.0 FILTER_KI estimator integral gain - See estimator documentation float 0.01f 0 1.0 FILTER_KP_COR estimator proportional gain on external attitude correction - See estimator documentation float 10.0f 0 1.0 FILTER_ACCMARGIN allowable accel norm margin around 1g to determine if accel is usable float 0.1f 0 1.0 FILTER_QUAD_INT Perform a quadratic averaging of LPF gyro data prior to integration (adds ~20 us to estimation loop on F1 processors) int 1 0 1 FILTER_MAT_EXP 1 - Use matrix exponential to improve gyro integration (adds ~90 us to estimation loop in F1 processors) 0 - use euler integration int 1 0 1 FILTER_USE_ACC Use accelerometer to correct gyro integration drift (adds ~70 us to estimation loop) int 1 0 1 CAL_GYRO_ARM True if desired to calibrate gyros on arm int false 0 1 GYROXY_LPF_ALPHA Low-pass filter constant on gyro X and Y axes - See estimator documentation float 0.3f 0 1.0 GYROZ_LPF_ALPHA Low-pass filter constant on gyro Z axis - See estimator documentation float 0.3f 0 1.0 ACC_LPF_ALPHA Low-pass filter constant on all accel axes - See estimator documentation float 0.5f 0 1.0 GYRO_X_BIAS Constant x-bias of gyroscope readings float 0.0f -1.0 1.0 GYRO_Y_BIAS Constant y-bias of gyroscope readings float 0.0f -1.0 1.0 GYRO_Z_BIAS Constant z-bias of gyroscope readings float 0.0f -1.0 1.0 ACC_X_BIAS Constant x-bias of accelerometer readings float 0.0f -2.0 2.0 ACC_Y_BIAS Constant y-bias of accelerometer readings float 0.0f -2.0 2.0 ACC_Z_BIAS Constant z-bias of accelerometer readings float 0.0f -2.0 2.0 ACC_X_TEMP_COMP Linear x-axis temperature compensation constant float 0.0f -2.0 2.0 ACC_Y_TEMP_COMP Linear y-axis temperature compensation constant float 0.0f -2.0 2.0 ACC_Z_TEMP_COMP Linear z-axis temperature compensation constant float 0.0f -2.0 2.0 MAG_A11_COMP Soft iron compensation constant float 1.0f -999.0 999.0 MAG_A12_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A13_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A21_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A22_COMP Soft iron compensation constant float 1.0f -999.0 999.0 MAG_A23_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A31_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A32_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A33_COMP Soft iron compensation constant float 1.0f -999.0 999.0 MAG_X_BIAS Hard iron compensation constant float 0.0f -999.0 999.0 MAG_Y_BIAS Hard iron compensation constant float 0.0f -999.0 999.0 MAG_Z_BIAS Hard iron compensation constant float 0.0f -999.0 999.0 BARO_BIAS Barometer measurement bias (Pa) float 0.0f 0 inf GROUND_LEVEL Altitude of ground level (m) float 1387.0f -1000 10000 DIFF_PRESS_BIAS Differential Pressure Bias (Pa) float 0.0f -10 10 RC_TYPE Type of RC input 0 - PPM, 1 - SBUS int 0 0 1 RC_X_CHN RC input channel mapped to x-axis commands [0 - indexed] int 0 0 3 RC_Y_CHN RC input channel mapped to y-axis commands [0 - indexed] int 1 0 3 RC_Z_CHN RC input channel mapped to z-axis commands [0 - indexed] int 3 0 3 RC_F_CHN RC input channel mapped to F-axis commands [0 - indexed] int 2 0 3 RC_ATT_OVRD_CHN RC switch mapped to attitude override [0 indexed, -1 to disable] int 4 4 7 RC_THR_OVRD_CHN RC switch channel mapped to throttle override [0 indexed, -1 to disable] int 4 4 7 RC_ATT_CTRL_CHN RC switch channel mapped to attitude control type [0 indexed, -1 to disable] int -1 4 7 ARM_CHANNEL RC switch channel mapped to arming (only if PARAM_ARM_STICKS is false) [0 indexed, -1 to disable] int -1 4 7 RC_NUM_CHN number of RC input channels int 6 1 8 SWITCH_5_DIR RC switch 5 toggle direction int 1 -1 1 SWITCH_6_DIR RC switch 6 toggle direction int 1 -1 1 SWITCH_7_DIR RC switch 7 toggle direction int 1 -1 1 SWITCH_8_DIR RC switch 8 toggle direction int 1 -1 1 RC_OVRD_DEV RC stick deviation from center for override float 0.1 0.0 1.0 OVRD_LAG_TIME RC stick deviation lag time before returning control (ms) int 1000 0 100000 MIN_THROTTLE Take minimum throttle between RC and computer at all times int true 0 1 RC_ATT_MODE Attitude mode for RC sticks (0: rate, 1: angle). Overridden if RC_ATT_CTRL_CHN is set. int 1 0 1 RC_MAX_ROLL Maximum roll angle command sent by full deflection of RC sticks float 0.786f 0.0 3.14159 RC_MAX_PITCH Maximum pitch angle command sent by full stick deflection of RC sticks float 0.786f 0.0 3.14159 RC_MAX_ROLLRATE Maximum roll rate command sent by full stick deflection of RC sticks float 3.14159f 0.0 9.42477796077 RC_MAX_PITCHRATE Maximum pitch command sent by full stick deflection of RC sticks float 3.14159f 0.0 3.14159 RC_MAX_YAWRATE Maximum pitch command sent by full stick deflection of RC sticks float 1.507f 0.0 3.14159 MIXER Which mixer to choose - See Mixer documentation int Mixer::INVALID_MIXER 0 10 FIXED_WING switches on pass-through commands for fixed-wing operation int false 0 1 ELEVATOR_REV reverses elevator servo output int 0 0 1 AIL_REV reverses aileron servo output int 0 0 1 RUDDER_REV reverses rudder servo output int 0 0 1 FC_ROLL roll angle (deg) of flight controller wrt aircraft body float 0.0f 0 360 FC_PITCH pitch angle (deg) of flight controller wrt aircraft body float 0.0f 0 360 FC_YAW yaw angle (deg) of flight controller wrt aircraft body float 0.0f 0 360 ARM_THRESHOLD RC deviation from max/min in yaw and throttle for arming and disarming check (us) float 0.15 0 500 OFFBOARD_TIMEOUT Timeout in milliseconds for offboard commands, after which RC override is activated int 100 0 100000","title":"Description of all Parameters"},{"location":"user-guide/performance/","text":"Improving Performance ROSflight supplies several methods to improve the performance of your aircraft. Tuning gains, adding feed-forward torques, and tuning the estimator are three ways to get your aircraft flying great! Gain Tuning Because there are a wide variety of multirotors out there, no one set of PID controller gains will be optimal for all vehicles. The default set of gains is relatively conservative for most platforms, and should be somewhat airworthy in most cases. However, depending on the inertia-to-torque ratio on your MAV, you may have to change these gains considerably. There are some great tutorials online on multirotor gain tuning; this is another tried-and-true method used to great effect at BYU. If you are unfamiliar with PIDs, you should probably go read about them before trying to tune a multirotor. Getting an understanding for what is going on will definitely guide your decision making process as you try to find better gains. While tuning controller gains, it is very likely that the multirotor will oscillate out of control. To handle this scenario, we generally add what we call \"training wheels\" to the multirotors we are tuning. These amount to thin carbon rods in the shape of an X zip-tied to the landing gear. This widens out the base of the multirotor so if you come down on a hard oscillation, chances are the vehicle will land upright, hopefully without a prop strike, or worse, battery damage with a thermal runaway event. If the battery is not tucked inside the main frame, it is wise to add some foam as protection to the battery. Here is a video of a maiden flight of ROSflight with \"training wheels\" attached. Now, for the procedure on tuning. Tuning Roll and Pitch angles Here is a flowchart describing my PID tuning process for roll and pitch: You may want to do another D-tuning iteration. Additionally, sometimes it is helpful to do a little tweaking on roll and pitch separately to eek out a little more performance from the differences in roll and pitch dynamics of your vehicle. Notice that we did not include any I tuning. As a general rule, try to keep the I gain as low as possible. It will always slow your response rate to input, and it can induce low frequency oscillations. You should only have I gain on roll and pitch if one of the following is true: You expect your CG to change, and/or You expect your rotor geometry to change Both of these are pretty rare. Instead, use your RC transmitter to trim the aircraft so it hovers with no stick input. In the RC trim calculation section, we will use the RC trim to calculate a feed-forward torque on the roll, pitch and yaw rates. Tuning Yaw rate Dynamically and algorithmically, using a D gain in yaw-rate control has no significant advantage. Controlling with derivative requires differentiating gyro measurements, which tends to be pretty noisy. In our experience, putting D in rate controllers on multirotors has always decreased performance. Tuning yaw rate is generally pretty easy. Basically, keep cranking it up until you feel like it's \"locked in\". Sometimes, a little bit of I (on the order of 0.1P) can help with this as well. The problem with too much P on yaw rate generally manifests itself in motor saturation. Some, especially larger, multirotors have problems getting enough control authority in yaw with the propellers being aligned flat. After you are done tuning, you might want to look at a plot of motor commands during a fairly aggressive flight. Underactuated yaw will be pretty obvious in these plots, because you will see the motor commands railing. To fix this, you can put shims between the arm mounts and the motors to tilt the motors just a little bit in the direction of yaw for that motor. RC trim In the vast majority of cases, your multirotor will not be built perfectly. The CG could be slightly off, or your motors, speed controllers and propellers could be slightly different. One way to fix this is by adding an integrator. Integrators get rid of static offsets such as those just mentioned. However, as explained above, integrators also always slow vehicle response. In our case, since this offset is going to be constant, we can instead find a \"feed-forward\", or equilibrium offset, torque that you need to apply to hover without drift. Use the RC transmitter to find the \"equilibrium torques\" about the x, y, and z axes to keep the multirotor level. This is done by trimming the aircraft with the RC trims. These are usually the little switches next to the sticks on your transmitter. Adjust these until you can hover the multirotor without touching the sticks. Next, land the multirotor, disarm, center the sticks and perform a trim calibration with rosservice call /calibrate_rc_trim . ROSflight then uses the trim settings on your transmitter to find these feed-forward, or equilibrium, torques that need to be applied post-controller to keep the multirotor level. These torques will be applied to all future commands (both from the companion computer and RC), so you will need to zero out your transmitter trims after calibration . Estimator Tuning ROSflight uses a non-linear complementary filter, based on the quaternion implementation of \" Non-linear complementary filters on the special orthogonal group \" by Robert Mahony 1 , to estimate attitude and angular rates. The implementation has been improved with suggestions from \" Attitude Representation and Kinematic Propagation for Low-Cost UAVs \" by Robert Casey 2 . A write-up of the derivation and implementation details can be found in the LaTeX report in reports/estimator.tex . (You'll need to be able to compile LaTeX sources to view the PDF). In addition to the complementary filter, accelerometer and gyro measurements are filtered using a simple low-pass filter (LPF) to cut out noise from vibrations. A block diagram of the estimator is shown below for reference. y_{gyro} y_{gyro} and y_{acc} y_{acc} are gyro and accelerometer measurements, respectively and \\beta_{gyro} \\beta_{gyro} is the estimated gyro biases. Tuning the Low-Pass Filter Gains The ACC_LPF_ALPHA and GYRO_LPF_ALPHA parameters are used in the following low-pass-filter implementation (see lines 98-106 of estimator.c ): x_t = (1-\\alpha)y_t + \\alpha x_{t-1} x_t = (1-\\alpha)y_t + \\alpha x_{t-1} where y_t y_t is the measurement and x_t x_t is the filtered value. Lowering \\alpha \\alpha will reduce lag in response, so if you feel like your MAV is sluggish despite all attempts at controller gain tuning, consider reducing \\alpha \\alpha . Reducing \\alpha \\alpha too far, however will result in a lot of noise from the sensors making its way into the motors. This can cause motors to get really hot, so make sure you check motor temperature if you are changing the low-pass filter constants. Tuning the Complementary Filter The complementary filter has two gains, k_p k_p and k_i k_i . For a complete understanding of how these work, we recommend reading the Mahony Paper, or the technical report in the reports folder. In short, k_p k_p can be thought of as the strength of accelerometer measurements in the filter, and the k_i k_i gain is the integral constant on the gyro bias. These values should probably not be changed. Before you go changing these values, make sure you completely understand how they work in the filter. If you do decide to change these values, you should stick to the following rule of thumb. k_i \\approx \\tfrac{k_p}{10}. k_i \\approx \\tfrac{k_p}{10}. External Attitude Measurements Because the onboard attitude estimator uses only inertial measurements, the estimates can deviate from truth. This is especially true during extended periods of accelerated flight, during which the gravity vector cannot be measured. Attitude measurements from an external source can be applied to the filter to help improve performance. These external attitude measurements might come from a higher-level estimator running on the companion computer that fuses additional information from GPS, vision, or a motion capture system. To send these updates to the flight controller, publish a geometry_msgs/Quaternion message to the external_attitude topic to which rosflight_io subscribes. The degree to which this update will be trusted is tuned with the FILTER_KP_EXT parameter. Mahony, R., Hamel, T. and Pflimlin, J. (2008). Nonlinear Complementary Filters on the Special Orthogonal Group. IEEE Transactions on Automatic Control, 53(5), pp.1203-1218. Casey, R., Karpenko, M., Curry, R. and Elkaim, G. (2013). Attitude Representation and Kinematic Propagation for Low-Cost UAVs. AIAA Guidance, Navigation, and Control (GNC) Conference.","title":"Improving Performance"},{"location":"user-guide/performance/#improving-performance","text":"ROSflight supplies several methods to improve the performance of your aircraft. Tuning gains, adding feed-forward torques, and tuning the estimator are three ways to get your aircraft flying great!","title":"Improving Performance"},{"location":"user-guide/performance/#gain-tuning","text":"Because there are a wide variety of multirotors out there, no one set of PID controller gains will be optimal for all vehicles. The default set of gains is relatively conservative for most platforms, and should be somewhat airworthy in most cases. However, depending on the inertia-to-torque ratio on your MAV, you may have to change these gains considerably. There are some great tutorials online on multirotor gain tuning; this is another tried-and-true method used to great effect at BYU. If you are unfamiliar with PIDs, you should probably go read about them before trying to tune a multirotor. Getting an understanding for what is going on will definitely guide your decision making process as you try to find better gains. While tuning controller gains, it is very likely that the multirotor will oscillate out of control. To handle this scenario, we generally add what we call \"training wheels\" to the multirotors we are tuning. These amount to thin carbon rods in the shape of an X zip-tied to the landing gear. This widens out the base of the multirotor so if you come down on a hard oscillation, chances are the vehicle will land upright, hopefully without a prop strike, or worse, battery damage with a thermal runaway event. If the battery is not tucked inside the main frame, it is wise to add some foam as protection to the battery. Here is a video of a maiden flight of ROSflight with \"training wheels\" attached. Now, for the procedure on tuning.","title":"Gain Tuning"},{"location":"user-guide/performance/#tuning-roll-and-pitch-angles","text":"Here is a flowchart describing my PID tuning process for roll and pitch: You may want to do another D-tuning iteration. Additionally, sometimes it is helpful to do a little tweaking on roll and pitch separately to eek out a little more performance from the differences in roll and pitch dynamics of your vehicle. Notice that we did not include any I tuning. As a general rule, try to keep the I gain as low as possible. It will always slow your response rate to input, and it can induce low frequency oscillations. You should only have I gain on roll and pitch if one of the following is true: You expect your CG to change, and/or You expect your rotor geometry to change Both of these are pretty rare. Instead, use your RC transmitter to trim the aircraft so it hovers with no stick input. In the RC trim calculation section, we will use the RC trim to calculate a feed-forward torque on the roll, pitch and yaw rates.","title":"Tuning Roll and Pitch angles"},{"location":"user-guide/performance/#tuning-yaw-rate","text":"Dynamically and algorithmically, using a D gain in yaw-rate control has no significant advantage. Controlling with derivative requires differentiating gyro measurements, which tends to be pretty noisy. In our experience, putting D in rate controllers on multirotors has always decreased performance. Tuning yaw rate is generally pretty easy. Basically, keep cranking it up until you feel like it's \"locked in\". Sometimes, a little bit of I (on the order of 0.1P) can help with this as well. The problem with too much P on yaw rate generally manifests itself in motor saturation. Some, especially larger, multirotors have problems getting enough control authority in yaw with the propellers being aligned flat. After you are done tuning, you might want to look at a plot of motor commands during a fairly aggressive flight. Underactuated yaw will be pretty obvious in these plots, because you will see the motor commands railing. To fix this, you can put shims between the arm mounts and the motors to tilt the motors just a little bit in the direction of yaw for that motor.","title":"Tuning Yaw rate"},{"location":"user-guide/performance/#rc-trim","text":"In the vast majority of cases, your multirotor will not be built perfectly. The CG could be slightly off, or your motors, speed controllers and propellers could be slightly different. One way to fix this is by adding an integrator. Integrators get rid of static offsets such as those just mentioned. However, as explained above, integrators also always slow vehicle response. In our case, since this offset is going to be constant, we can instead find a \"feed-forward\", or equilibrium offset, torque that you need to apply to hover without drift. Use the RC transmitter to find the \"equilibrium torques\" about the x, y, and z axes to keep the multirotor level. This is done by trimming the aircraft with the RC trims. These are usually the little switches next to the sticks on your transmitter. Adjust these until you can hover the multirotor without touching the sticks. Next, land the multirotor, disarm, center the sticks and perform a trim calibration with rosservice call /calibrate_rc_trim . ROSflight then uses the trim settings on your transmitter to find these feed-forward, or equilibrium, torques that need to be applied post-controller to keep the multirotor level. These torques will be applied to all future commands (both from the companion computer and RC), so you will need to zero out your transmitter trims after calibration .","title":"RC trim"},{"location":"user-guide/performance/#estimator-tuning","text":"ROSflight uses a non-linear complementary filter, based on the quaternion implementation of \" Non-linear complementary filters on the special orthogonal group \" by Robert Mahony 1 , to estimate attitude and angular rates. The implementation has been improved with suggestions from \" Attitude Representation and Kinematic Propagation for Low-Cost UAVs \" by Robert Casey 2 . A write-up of the derivation and implementation details can be found in the LaTeX report in reports/estimator.tex . (You'll need to be able to compile LaTeX sources to view the PDF). In addition to the complementary filter, accelerometer and gyro measurements are filtered using a simple low-pass filter (LPF) to cut out noise from vibrations. A block diagram of the estimator is shown below for reference. y_{gyro} y_{gyro} and y_{acc} y_{acc} are gyro and accelerometer measurements, respectively and \\beta_{gyro} \\beta_{gyro} is the estimated gyro biases.","title":"Estimator Tuning"},{"location":"user-guide/performance/#tuning-the-low-pass-filter-gains","text":"The ACC_LPF_ALPHA and GYRO_LPF_ALPHA parameters are used in the following low-pass-filter implementation (see lines 98-106 of estimator.c ): x_t = (1-\\alpha)y_t + \\alpha x_{t-1} x_t = (1-\\alpha)y_t + \\alpha x_{t-1} where y_t y_t is the measurement and x_t x_t is the filtered value. Lowering \\alpha \\alpha will reduce lag in response, so if you feel like your MAV is sluggish despite all attempts at controller gain tuning, consider reducing \\alpha \\alpha . Reducing \\alpha \\alpha too far, however will result in a lot of noise from the sensors making its way into the motors. This can cause motors to get really hot, so make sure you check motor temperature if you are changing the low-pass filter constants.","title":"Tuning the Low-Pass Filter Gains"},{"location":"user-guide/performance/#tuning-the-complementary-filter","text":"The complementary filter has two gains, k_p k_p and k_i k_i . For a complete understanding of how these work, we recommend reading the Mahony Paper, or the technical report in the reports folder. In short, k_p k_p can be thought of as the strength of accelerometer measurements in the filter, and the k_i k_i gain is the integral constant on the gyro bias. These values should probably not be changed. Before you go changing these values, make sure you completely understand how they work in the filter. If you do decide to change these values, you should stick to the following rule of thumb. k_i \\approx \\tfrac{k_p}{10}. k_i \\approx \\tfrac{k_p}{10}.","title":"Tuning the Complementary Filter"},{"location":"user-guide/performance/#external-attitude-measurements","text":"Because the onboard attitude estimator uses only inertial measurements, the estimates can deviate from truth. This is especially true during extended periods of accelerated flight, during which the gravity vector cannot be measured. Attitude measurements from an external source can be applied to the filter to help improve performance. These external attitude measurements might come from a higher-level estimator running on the companion computer that fuses additional information from GPS, vision, or a motion capture system. To send these updates to the flight controller, publish a geometry_msgs/Quaternion message to the external_attitude topic to which rosflight_io subscribes. The degree to which this update will be trusted is tuned with the FILTER_KP_EXT parameter. Mahony, R., Hamel, T. and Pflimlin, J. (2008). Nonlinear Complementary Filters on the Special Orthogonal Group. IEEE Transactions on Automatic Control, 53(5), pp.1203-1218. Casey, R., Karpenko, M., Curry, R. and Elkaim, G. (2013). Attitude Representation and Kinematic Propagation for Low-Cost UAVs. AIAA Guidance, Navigation, and Control (GNC) Conference.","title":"External Attitude Measurements"},{"location":"user-guide/preflight-checks/","text":"Pre-Flight Checklist This is an example of a ROSflight pre-flight checklist. You will likely need to augment this with checks specific to both (a) your hardware and (b) the code running on your companion computer. Before powering up motors ROS is running on the companion computer, communicating with the base station rosflight_io reports no errors Sensors are calibrated and publishing IMU (re-calibrate every flight): rosservice call /calibrate_imu Barometer: rosservice call /calibrate_baro Sonar (if attached) Airspeed (if attached) Estimated attitude is being published and looks accurate Published outputs look reasonable Parameter Check (if using a fixed-wing, there are about 8 parameters you will need to change from default) RC communication Failsafe behavior Arming and disarming RC override behavior RC range test Wire-wiggle test (wiggle all wires to look for bad connections) If desired, logging is turned on (e.g. recording a rosbag) After Powering Up Motors Danger Be sure the flight controller is disarmed before powering up motors!!! Arm/Disarm test Propeller spin test (check directions and response to stick inputs) Control surface test (fixed-wing) Response to offboard controls","title":"Pre-Flight Checks"},{"location":"user-guide/preflight-checks/#pre-flight-checklist","text":"This is an example of a ROSflight pre-flight checklist. You will likely need to augment this with checks specific to both (a) your hardware and (b) the code running on your companion computer.","title":"Pre-Flight Checklist"},{"location":"user-guide/preflight-checks/#before-powering-up-motors","text":"ROS is running on the companion computer, communicating with the base station rosflight_io reports no errors Sensors are calibrated and publishing IMU (re-calibrate every flight): rosservice call /calibrate_imu Barometer: rosservice call /calibrate_baro Sonar (if attached) Airspeed (if attached) Estimated attitude is being published and looks accurate Published outputs look reasonable Parameter Check (if using a fixed-wing, there are about 8 parameters you will need to change from default) RC communication Failsafe behavior Arming and disarming RC override behavior RC range test Wire-wiggle test (wiggle all wires to look for bad connections) If desired, logging is turned on (e.g. recording a rosbag)","title":"Before powering up motors"},{"location":"user-guide/preflight-checks/#after-powering-up-motors","text":"Danger Be sure the flight controller is disarmed before powering up motors!!! Arm/Disarm test Propeller spin test (check directions and response to stick inputs) Control surface test (fixed-wing) Response to offboard controls","title":"After Powering Up Motors"},{"location":"user-guide/rc-configuration/","text":"RC Configuration Binding your Transmitter to your Receiver As of version 1.0, ROSflight only supports PPM receivers on F1 controllers, while F4 controllers support SBUS and PPM. If your transmitter/receiver setup only supports PWM output, we recommend using a PPM encoder such as the one here . Be sure to set the RC_TYPE parameter to 0 for PPM, or 1 for SBUS. Follow the instructions in your user manual to bind your transmitter to your RC receiver. You may also be able to find a guide on YouTube with instructions; just search for your particular transmitter and receiver model. RC Transmitter Calibration To avoid confusion and to reduce code complexity in the firmware source code, ROSflight does not perform software calibration of RC transmitters. This means that RC calibration must be done on the transmitter itself, as opposed to in software. This is pretty straight-forward for most modern transmitters. Configure the full stick output for each channel The easiest way to do this is to enter the \"Servo Setup\" Menu (for Spektrum transmitters) and change the servo travel variable. You can watch the raw RC readings from the flight controller by echoing the rc_raw topic from rosflight_io rostopic echo /rc_raw center both sticks on your transmitter Apply subtrim until the first four channels all read 1500 exactly (or as close as possible--some RC receivers are worse than others and cannot exactly output 1500 us) Set the channel endpoints so that maximum stick deflections result in readings of 1000 and 2000 us. You may want to follow this YouTube guide for channel calibration in betaflight: Calibrating RC endpoints with Taranis X9D . Configure stick directions for roll, pitch, and yaw channels. You now have to make sure your RC transmitter is sending commands consistent with the north-east-down (NED) frame assumed by ROSflight. You may find this graphic helpful. It shows all the basic stick positions, and the associated output from the first four channels when looking at a raw AETR (aileron, elevator, throttle, rudder) RC signal from rosflight_io . Make sure that the stick output is in the correct direction. It should be noted that channel assignment can be modified via the RC_*_CHN parameters. So, if you are using something other than AETR assignment, the channel index for each stick may be different, but the direction should be the same. Switch Configuration Switches can be configured for the following functions. To disable a switch for a specific, default function, set the corresponding parameter to -1 . Be sure to check that the switch directions operate as you intend, and reverse them in your transmitter if necessary. Safety Pilot Configuration The RC_ATT_OVRD_CHN parameter maps a switch to override attitude commands with RC control. The RC_THR_OVRD_CHN parameter maps a switch to override throttle commands with RC control. To override both with a single switch, set both parameters to the same value (this is the default behavior). Arming By default, arming is done with the sticks (left stick down and right to arm, down and left to disarm). To use a switch instead, set the ARM_CHANNEL parameter to the desired channel. Setting an arming switch disables arming with the sticks. Flight Mode If desired, you can map a switch to select between attitude control types (angle and rate) in flight by setting the RC_ATT_CTRL_CHN parameter to the desired channel. This can be useful if, for example, you are learning rate mode but want to be able to switch back to attitude mode to help stabilize the vehicle. This feature is disabled by default.","title":"RC Configuration"},{"location":"user-guide/rc-configuration/#rc-configuration","text":"","title":"RC Configuration"},{"location":"user-guide/rc-configuration/#binding-your-transmitter-to-your-receiver","text":"As of version 1.0, ROSflight only supports PPM receivers on F1 controllers, while F4 controllers support SBUS and PPM. If your transmitter/receiver setup only supports PWM output, we recommend using a PPM encoder such as the one here . Be sure to set the RC_TYPE parameter to 0 for PPM, or 1 for SBUS. Follow the instructions in your user manual to bind your transmitter to your RC receiver. You may also be able to find a guide on YouTube with instructions; just search for your particular transmitter and receiver model.","title":"Binding your Transmitter to your Receiver"},{"location":"user-guide/rc-configuration/#rc-transmitter-calibration","text":"To avoid confusion and to reduce code complexity in the firmware source code, ROSflight does not perform software calibration of RC transmitters. This means that RC calibration must be done on the transmitter itself, as opposed to in software. This is pretty straight-forward for most modern transmitters.","title":"RC Transmitter Calibration"},{"location":"user-guide/rc-configuration/#configure-the-full-stick-output-for-each-channel","text":"The easiest way to do this is to enter the \"Servo Setup\" Menu (for Spektrum transmitters) and change the servo travel variable. You can watch the raw RC readings from the flight controller by echoing the rc_raw topic from rosflight_io rostopic echo /rc_raw center both sticks on your transmitter Apply subtrim until the first four channels all read 1500 exactly (or as close as possible--some RC receivers are worse than others and cannot exactly output 1500 us) Set the channel endpoints so that maximum stick deflections result in readings of 1000 and 2000 us. You may want to follow this YouTube guide for channel calibration in betaflight: Calibrating RC endpoints with Taranis X9D .","title":"Configure the full stick output for each channel"},{"location":"user-guide/rc-configuration/#configure-stick-directions-for-roll-pitch-and-yaw-channels","text":"You now have to make sure your RC transmitter is sending commands consistent with the north-east-down (NED) frame assumed by ROSflight. You may find this graphic helpful. It shows all the basic stick positions, and the associated output from the first four channels when looking at a raw AETR (aileron, elevator, throttle, rudder) RC signal from rosflight_io . Make sure that the stick output is in the correct direction. It should be noted that channel assignment can be modified via the RC_*_CHN parameters. So, if you are using something other than AETR assignment, the channel index for each stick may be different, but the direction should be the same.","title":"Configure stick directions for roll, pitch, and yaw channels."},{"location":"user-guide/rc-configuration/#switch-configuration","text":"Switches can be configured for the following functions. To disable a switch for a specific, default function, set the corresponding parameter to -1 . Be sure to check that the switch directions operate as you intend, and reverse them in your transmitter if necessary.","title":"Switch Configuration"},{"location":"user-guide/rc-configuration/#safety-pilot-configuration","text":"The RC_ATT_OVRD_CHN parameter maps a switch to override attitude commands with RC control. The RC_THR_OVRD_CHN parameter maps a switch to override throttle commands with RC control. To override both with a single switch, set both parameters to the same value (this is the default behavior).","title":"Safety Pilot Configuration"},{"location":"user-guide/rc-configuration/#arming","text":"By default, arming is done with the sticks (left stick down and right to arm, down and left to disarm). To use a switch instead, set the ARM_CHANNEL parameter to the desired channel. Setting an arming switch disables arming with the sticks.","title":"Arming"},{"location":"user-guide/rc-configuration/#flight-mode","text":"If desired, you can map a switch to select between attitude control types (angle and rate) in flight by setting the RC_ATT_CTRL_CHN parameter to the desired channel. This can be useful if, for example, you are learning rate mode but want to be able to switch back to attitude mode to help stabilize the vehicle. This feature is disabled by default.","title":"Flight Mode"},{"location":"user-guide/ros-setup/","text":"Installing/Setting up ROS You will need to install ROS on both the companion computer and the base station laptop. Check out the official ROS Installation page for details on how to do this. Currently only the long-term support ROS Kinetic and ROS Melodic releases are supported, with the recommended operating system being Ubuntu 16.04 and 18.04 respectively. If storage and/or hardware resources are limited on your companion computer, you can install the bare-bones ROS package (e.g. ros-kinetic-ros-base ) instead of the full desktop version. Installing ROSflight You will need to install the ROSflight packages on both the companion computer and the base station computer. The companion computer will run the node that actually communicates with the flight controller over a serial connection, while the base station needs the message and service definitions to be able to call services or subscribe and publish to topics. From the apt Repository The recommended installation method for Ubuntu or Debian systems is to use the ROSflight packages in the official ROS apt repositories. If you have configured your system to use these repositories, as described in the ROS installation guide, you can install rosflight using the following, inserting the name of the ROS release you are using (e.g. \"kinetic\" or \"melodic\"): sudo apt install ros- ros_release -rosflight-pkgs The previous command will install all of the rosflight packages, including the Gazebo simulation packages. If installing on a companion computer with limited resources, you can instead install only rosflight_io : sudo apt install ros- ros_release -rosflight From Source If you prefer, or if binary packages are not available for your distribution or system architecture, you can install the ROSflight packages from source instead. First, set up a catkin workspace by following the directions here . Tip In order to ensure that new terminal windows are configured to use this workspace, you can add the line source ~/catkin_ws/devel/setup.bash to your ~/.bashrc file or its equivalent on other systems. (Change the path if your workspace is located somewhere other than ~/catkin_ws .) Next, download the source code into your workspace. Assuming that your workspace is located at ~/catkin_ws : cd ~/catkin_ws/src git clone https://github.com/rosflight/rosflight.git Pull down the submodules (there is a triple-layer submodule setup in the rosflight metapackage, so you have to remember the --recursive argument): cd rosflight git submodule update --init --recursive Install dependencies: cd ~/catkin_ws/src rosdep -y install --ignore-src --from-path rosflight Finally, build the packages: cd ~/catkin_ws catkin_make Running rosflight_io The rosflight_io node is the bridge between ROS and the MAVLink communication with the flight controller. This node must be run on the computer that has the physical serial connection to your flight controller. To run this node, use something like the following command (after starting a roscore ): rosrun rosflight rosflight_io _port: = /dev/ttyACM0 Replace /dev/ttyACM0 with the port your flight controller is connected to. The rosflight_io node could also be started from within a launch file with something like node pkg= rosflight type= rosflight_io name= rosflight_io output= screen param name= port value= /dev/ttyACM0 / /node Tip The optional (but recommended) output=\"screen\" option ensures that status messages from rosflight_io will be forwarded to the console from which you call roslaunch . For details on all parameters, topics, and services related to the rosflight_io node, refer to the documentation on the ROS wiki . Jetson TX2 Update As of Jetpack 4.2, with the CTI-L4T patch installed to use the TX2 mounted on a CTI Orbitty carrier board, the three drivers mentioned here are installed out of the box. It is likely that your Flip32/Naze32 board doesn't work correctly out of the box with the TX2. To fix this, you need to build some drivers in with the kernel. This process is pretty straight-forward. To build the kernel with additional USB drivers, follow the instructions and video found here . This video shows the CH341 module being added. However, there are a few additional drivers you will likely require. These include: USB Winchiphead CH341 Single Port Serial Driver USB Modem (CDC ACM) support USB CP210x family of UART Bridge Controllers After following the instructions to add these drivers, reboot your TX2 and your USB devices should show up in /dev/ttyUSB or /dev/ttyACM as you would expect.","title":"ROS Setup"},{"location":"user-guide/ros-setup/#installingsetting-up-ros","text":"You will need to install ROS on both the companion computer and the base station laptop. Check out the official ROS Installation page for details on how to do this. Currently only the long-term support ROS Kinetic and ROS Melodic releases are supported, with the recommended operating system being Ubuntu 16.04 and 18.04 respectively. If storage and/or hardware resources are limited on your companion computer, you can install the bare-bones ROS package (e.g. ros-kinetic-ros-base ) instead of the full desktop version.","title":"Installing/Setting up ROS"},{"location":"user-guide/ros-setup/#installing-rosflight","text":"You will need to install the ROSflight packages on both the companion computer and the base station computer. The companion computer will run the node that actually communicates with the flight controller over a serial connection, while the base station needs the message and service definitions to be able to call services or subscribe and publish to topics.","title":"Installing ROSflight"},{"location":"user-guide/ros-setup/#from-the-apt-repository","text":"The recommended installation method for Ubuntu or Debian systems is to use the ROSflight packages in the official ROS apt repositories. If you have configured your system to use these repositories, as described in the ROS installation guide, you can install rosflight using the following, inserting the name of the ROS release you are using (e.g. \"kinetic\" or \"melodic\"): sudo apt install ros- ros_release -rosflight-pkgs The previous command will install all of the rosflight packages, including the Gazebo simulation packages. If installing on a companion computer with limited resources, you can instead install only rosflight_io : sudo apt install ros- ros_release -rosflight","title":"From the apt Repository"},{"location":"user-guide/ros-setup/#from-source","text":"If you prefer, or if binary packages are not available for your distribution or system architecture, you can install the ROSflight packages from source instead. First, set up a catkin workspace by following the directions here . Tip In order to ensure that new terminal windows are configured to use this workspace, you can add the line source ~/catkin_ws/devel/setup.bash to your ~/.bashrc file or its equivalent on other systems. (Change the path if your workspace is located somewhere other than ~/catkin_ws .) Next, download the source code into your workspace. Assuming that your workspace is located at ~/catkin_ws : cd ~/catkin_ws/src git clone https://github.com/rosflight/rosflight.git Pull down the submodules (there is a triple-layer submodule setup in the rosflight metapackage, so you have to remember the --recursive argument): cd rosflight git submodule update --init --recursive Install dependencies: cd ~/catkin_ws/src rosdep -y install --ignore-src --from-path rosflight Finally, build the packages: cd ~/catkin_ws catkin_make","title":"From Source"},{"location":"user-guide/ros-setup/#running-rosflight_io","text":"The rosflight_io node is the bridge between ROS and the MAVLink communication with the flight controller. This node must be run on the computer that has the physical serial connection to your flight controller. To run this node, use something like the following command (after starting a roscore ): rosrun rosflight rosflight_io _port: = /dev/ttyACM0 Replace /dev/ttyACM0 with the port your flight controller is connected to. The rosflight_io node could also be started from within a launch file with something like node pkg= rosflight type= rosflight_io name= rosflight_io output= screen param name= port value= /dev/ttyACM0 / /node Tip The optional (but recommended) output=\"screen\" option ensures that status messages from rosflight_io will be forwarded to the console from which you call roslaunch . For details on all parameters, topics, and services related to the rosflight_io node, refer to the documentation on the ROS wiki .","title":"Running rosflight_io"},{"location":"user-guide/ros-setup/#jetson-tx2","text":"Update As of Jetpack 4.2, with the CTI-L4T patch installed to use the TX2 mounted on a CTI Orbitty carrier board, the three drivers mentioned here are installed out of the box. It is likely that your Flip32/Naze32 board doesn't work correctly out of the box with the TX2. To fix this, you need to build some drivers in with the kernel. This process is pretty straight-forward. To build the kernel with additional USB drivers, follow the instructions and video found here . This video shows the CH341 module being added. However, there are a few additional drivers you will likely require. These include: USB Winchiphead CH341 Single Port Serial Driver USB Modem (CDC ACM) support USB CP210x family of UART Bridge Controllers After following the instructions to add these drivers, reboot your TX2 and your USB devices should show up in /dev/ttyUSB or /dev/ttyACM as you would expect.","title":"Jetson TX2"}]}